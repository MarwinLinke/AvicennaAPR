from pathlib import Path
import tests4py.api as t4p
from fixkit.repair.pyae import PyAE
from fixkit.localization.t4p import Tests4PyLocalization
from fixkit.constants import DEFAULT_EXCLUDES

from isla.solver import ISLaSolver
import string

from avicenna.avicenna import OracleResult
from avicenna.avicenna import Avicenna
from typing import List, Tuple
from isla.language import Formula
from isla.language import ISLaUnparser


grammar = {
    "<start>": ["<arith_expr>"],
    "<arith_expr>": ["<function>(<number>)"],
    "<function>": ["sin", "cos", "tan", "sqrt"],
    "<number>": ["<maybe_minus><onenine><maybe_digits><maybe_frac>"],
    "<maybe_minus>": ["", "-"],
    "<onenine>": [str(num) for num in range(1, 10)],
    "<digit>": list(string.digits),
    "<maybe_digits>": ["", "<digits>"],
    "<digits>": ["<digit>", "<digit><digits>"],
    "<maybe_frac>": ["", ".<digits>"],
}

import math

def calculator(inp: str) -> float:
    """
        A simple calculator function that can evaluate arithmetic expressions
        and perform basic trigonometric functions and square root calculations.
    """

    return eval(
        str(inp), {"sqrt": math.sqrt, "sin": math.sin, "cos": math.cos, "tan": math.tan}
    )


def oracle(inp: str):
    """
    This function serves as an oracle or intermediary that catches and handles exceptions 
    generated by the 'calculator' function.
    It aims to determine whether an input triggers a bug in the 'calculator' function.

    Args:
        inp (str): The input string to be passed to the 'calculator' function.

    Returns:
        OracleResult: An enumerated type 'OracleResult' indicating the outcome of the function execution.
            - OracleResult.PASSING: Returned if the calculator function executes without any exception
            - OracleResult.FAILING: Returned if the calculator function raises a ValueError exception, indicating a potential bug.
    """
    try:
        calculator(inp)
    except ValueError as e:
        return OracleResult.FAILING
    return OracleResult.PASSING

solver = ISLaSolver(grammar)
passing = []
failing = []

for i in range(100):
    result = solver.solve()
    if oracle(result) == OracleResult.FAILING:
        failing.append(str(result))
        break
    else:
        passing.append(str(result))

print(passing, failing)


avicenna = Avicenna(
    grammar,
    oracle,
    initial_inputs = passing + failing,
    max_iterations = 10
)

diagnosis: Tuple[Formula, float, float] = avicenna.explain()


print(f"Avicenna determined the following constraints to describe the failure circumstances:\n")
print(ISLaUnparser(diagnosis[0]).unparse())
print(f"Avicenna calculated a precision of {diagnosis[1]*100:.2f}% and a recall of {diagnosis[2]*100:.2f}%", end="\n\n")

for diagnosis in avicenna.get_equivalent_best_formulas():
    solver = ISLaSolver(
        grammar,
        formula=diagnosis[0],
        enable_optimized_z3_queries=False)
    
    for _ in range(20):
        try:
            inp = solver.solve()
            print(str(inp).ljust(30), oracle(inp))
        except StopIteration:
            continue
