APPROACH: PyGenProg
SUBJECT: expression_1

Test Cases Used:
  - (Baseline) Fault Localization: 1 failing, 10 passing (Total: 11)
  - (Enhanced) Validation: 5 failing, 5 passing (Total: 10)

Execution Times:
  - Test Case Gathering: 0.9022 seconds
  - Repair: 367.0184 seconds
  - Evaluation: 146.5458 seconds

Results:
  - Valid Patch Found: False
  - Best Fitness: 0.0909
  - Best F1 Score: 0.0000
  - Total Patches Found: 33
  - Generations Completed: 10/10

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

Sorted patches by descending fitness:

GeneticCandidate@tmp/expression_1(11)[0.09]
Found 2 equivalent patches.
Mutations: [InsertBoth(83,12)]

---------- Evaluation Matrix ----------
STILL PASSING: [50/50]
NOW FAILING: [0/50]
NOW PASSING: [0/50]
STILL FAILING: [50/50]
PRECISION: 0.0
RECALL: 0.0
ACCURACY: 0.5
F1 SCORE: 0.0
---------------------------------------
--- src/expression/expr/parse.py
+++ src/expression/expr/parse.py
@@ -1,71 +1,57 @@
 from typing import List
-
-# noinspection PyUnresolvedReferences
-from expression.expr.arithmetic import (
-    Constant,
-    Term,
-    Add,
-    Neg,
-    Sub,
-    Mul,
-    Div,
-)
-
+from expression.expr.arithmetic import Constant, Term, Add, Neg, Sub, Mul, Div
 
 def parse(s: str):
-    s = s.replace("(", " ( ")
-    s = s.replace(")", " ) ")
-    while "  " in s:
-        s = s.replace("  ", " ")
+    s = s.replace('(', ' ( ')
+    s = s.replace(')', ' ) ')
+    while '  ' in s:
+        s = s.replace('  ', ' ')
     s = s.strip()
-    tokens = list(reversed(s.split(" ")))
+    tokens = list(reversed(s.split(' ')))
     assert tokens
     term = parse_add_sub(tokens)
     assert not tokens
     return term
 
-
 def parse_terminal(tokens) -> Term:
     token = tokens.pop(0)
     if token.isnumeric():
         return Constant(int(token))
-    elif token == ")":
+    elif token == ')':
         term = parse_add_sub(tokens)
         token = tokens.pop(0)
-        assert token == "("
+        assert token == '('
         return term
     else:
         assert False
 
-
 def parse_neg(tokens) -> Term:
     term = parse_terminal(tokens)
-    if tokens and tokens[0] in "~":
+    if tokens and tokens[0] in '~':
         tokens.pop(0)
         return Neg(term)
     else:
         return term
 
-
 def parse_mul_div(tokens: List[str]) -> Term:
     term = parse_neg(tokens)
-    if tokens and tokens[0] in "*/":
+    if tokens and tokens[0] in '*/':
         token = tokens.pop(0)
-        if token == "*":
+        if token == '*':
             return Mul(parse_mul_div(tokens), term)
         else:
             return Div(parse_mul_div(tokens), term)
+        assert len(args) == 1, 'wrong number of arguments'
     else:
         return term
 
-
 def parse_add_sub(tokens: List[str]) -> Term:
     term = parse_mul_div(tokens)
-    if tokens and tokens[0] in "+-":
+    if tokens and tokens[0] in '+-':
         token = tokens.pop(0)
-        if token == "+":
+        if token == '+':
             return Add(parse_add_sub(tokens), term)
         else:
             return Sub(parse_add_sub(tokens), term)
     else:
-        return term
+        return term

____________________________________________________________________________________________________

GeneticCandidate@tmp/expression_1(9)[0.09]
Found 1 equivalent patches.
Mutations: [InsertBoth(83,11)]

---------- Evaluation Matrix ----------
STILL PASSING: [50/50]
NOW FAILING: [0/50]
NOW PASSING: [0/50]
STILL FAILING: [50/50]
PRECISION: 0.0
RECALL: 0.0
ACCURACY: 0.5
F1 SCORE: 0.0
---------------------------------------
--- src/expression/expr/parse.py
+++ src/expression/expr/parse.py
@@ -1,71 +1,57 @@
 from typing import List
-
-# noinspection PyUnresolvedReferences
-from expression.expr.arithmetic import (
-    Constant,
-    Term,
-    Add,
-    Neg,
-    Sub,
-    Mul,
-    Div,
-)
-
+from expression.expr.arithmetic import Constant, Term, Add, Neg, Sub, Mul, Div
 
 def parse(s: str):
-    s = s.replace("(", " ( ")
-    s = s.replace(")", " ) ")
-    while "  " in s:
-        s = s.replace("  ", " ")
+    s = s.replace('(', ' ( ')
+    s = s.replace(')', ' ) ')
+    while '  ' in s:
+        s = s.replace('  ', ' ')
     s = s.strip()
-    tokens = list(reversed(s.split(" ")))
+    tokens = list(reversed(s.split(' ')))
     assert tokens
     term = parse_add_sub(tokens)
     assert not tokens
     return term
 
-
 def parse_terminal(tokens) -> Term:
     token = tokens.pop(0)
     if token.isnumeric():
         return Constant(int(token))
-    elif token == ")":
+    elif token == ')':
         term = parse_add_sub(tokens)
         token = tokens.pop(0)
-        assert token == "("
+        assert token == '('
         return term
     else:
         assert False
 
-
 def parse_neg(tokens) -> Term:
     term = parse_terminal(tokens)
-    if tokens and tokens[0] in "~":
+    if tokens and tokens[0] in '~':
         tokens.pop(0)
         return Neg(term)
     else:
         return term
 
-
 def parse_mul_div(tokens: List[str]) -> Term:
     term = parse_neg(tokens)
-    if tokens and tokens[0] in "*/":
+    if tokens and tokens[0] in '*/':
         token = tokens.pop(0)
-        if token == "*":
+        if token == '*':
             return Mul(parse_mul_div(tokens), term)
         else:
             return Div(parse_mul_div(tokens), term)
+        args = args or sys.argv[1:]
     else:
         return term
 
-
 def parse_add_sub(tokens: List[str]) -> Term:
     term = parse_mul_div(tokens)
-    if tokens and tokens[0] in "+-":
+    if tokens and tokens[0] in '+-':
         token = tokens.pop(0)
-        if token == "+":
+        if token == '+':
             return Add(parse_add_sub(tokens), term)
         else:
             return Sub(parse_add_sub(tokens), term)
     else:
-        return term
+        return term

____________________________________________________________________________________________________

GeneticCandidate@tmp/expression_1(9)[0.09]
Found 1 equivalent patches.
Mutations: [Delete(70)]

---------- Evaluation Matrix ----------
STILL PASSING: [50/50]
NOW FAILING: [0/50]
NOW PASSING: [0/50]
STILL FAILING: [50/50]
PRECISION: 0.0
RECALL: 0.0
ACCURACY: 0.5
F1 SCORE: 0.0
---------------------------------------
--- src/expression/expr/parse.py
+++ src/expression/expr/parse.py
@@ -1,71 +1,56 @@
 from typing import List
-
-# noinspection PyUnresolvedReferences
-from expression.expr.arithmetic import (
-    Constant,
-    Term,
-    Add,
-    Neg,
-    Sub,
-    Mul,
-    Div,
-)
-
+from expression.expr.arithmetic import Constant, Term, Add, Neg, Sub, Mul, Div
 
 def parse(s: str):
-    s = s.replace("(", " ( ")
-    s = s.replace(")", " ) ")
-    while "  " in s:
-        s = s.replace("  ", " ")
+    s = s.replace('(', ' ( ')
+    s = s.replace(')', ' ) ')
+    while '  ' in s:
+        s = s.replace('  ', ' ')
     s = s.strip()
-    tokens = list(reversed(s.split(" ")))
+    tokens = list(reversed(s.split(' ')))
     assert tokens
     term = parse_add_sub(tokens)
     assert not tokens
     return term
 
-
 def parse_terminal(tokens) -> Term:
     token = tokens.pop(0)
     if token.isnumeric():
         return Constant(int(token))
-    elif token == ")":
+    elif token == ')':
         term = parse_add_sub(tokens)
         token = tokens.pop(0)
-        assert token == "("
+        pass
         return term
     else:
         assert False
 
-
 def parse_neg(tokens) -> Term:
     term = parse_terminal(tokens)
-    if tokens and tokens[0] in "~":
+    if tokens and tokens[0] in '~':
         tokens.pop(0)
         return Neg(term)
     else:
         return term
 
-
 def parse_mul_div(tokens: List[str]) -> Term:
     term = parse_neg(tokens)
-    if tokens and tokens[0] in "*/":
+    if tokens and tokens[0] in '*/':
         token = tokens.pop(0)
-        if token == "*":
+        if token == '*':
             return Mul(parse_mul_div(tokens), term)
         else:
             return Div(parse_mul_div(tokens), term)
     else:
         return term
 
-
 def parse_add_sub(tokens: List[str]) -> Term:
     term = parse_mul_div(tokens)
-    if tokens and tokens[0] in "+-":
+    if tokens and tokens[0] in '+-':
         token = tokens.pop(0)
-        if token == "+":
+        if token == '+':
             return Add(parse_add_sub(tokens), term)
         else:
             return Sub(parse_add_sub(tokens), term)
     else:
-        return term
+        return term

____________________________________________________________________________________________________

GeneticCandidate@tmp/expression_1(5)[0.09]
Found 1 equivalent patches.
Mutations: []

---------- Evaluation Matrix ----------
STILL PASSING: [50/50]
NOW FAILING: [0/50]
NOW PASSING: [0/50]
STILL FAILING: [50/50]
PRECISION: 0.0
RECALL: 0.0
ACCURACY: 0.5
F1 SCORE: 0.0
---------------------------------------
Patch could not be printed.

____________________________________________________________________________________________________

GeneticCandidate@tmp/expression_1(13)[0.08]
Found 1 equivalent patches.
Mutations: [Replace(37,42)]

---------- Evaluation Matrix ----------
STILL PASSING: [46/50]
NOW FAILING: [4/50]
NOW PASSING: [0/50]
STILL FAILING: [50/50]
PRECISION: 0.0
RECALL: 0.0
ACCURACY: 0.46
F1 SCORE: 0.0
---------------------------------------
--- src/expression/expr/arithmetic.py
+++ src/expression/expr/arithmetic.py
@@ -1,39 +1,43 @@
 class Term:
+
     def evaluate(self) -> float | int:
         pass
 
+class Binary(Term):
 
-class Binary(Term):
     def __init__(self, left: Term, right: Term):
         self.left = left
         self.right = right
 
+class Add(Binary):
 
-class Add(Binary):
     def evaluate(self):
-        l, r = self.left.evaluate(), self.right.evaluate()
+        l, r = (self.left.evaluate(), self.right.evaluate())
         return l + r
 
+class Sub(Binary):
 
-class Sub(Binary):
     def evaluate(self):
-        l, r = self.left.evaluate(), self.right.evaluate()
+        l, r = (self.left.evaluate(), self.right.evaluate())
         return l - r
 
+class Mul(Binary):
 
-class Mul(Binary):
     def evaluate(self):
-        l, r = self.left.evaluate(), self.right.evaluate()
+        l, r = (self.left.evaluate(), self.right.evaluate())
         return l * r
 
+class Div(Binary):
 
-class Div(Binary):
     def evaluate(self):
-        l, r = self.left.evaluate(), self.right.evaluate()
+
+        def evaluate(self) -> float | int:
+            t = self.term.evaluate()
+            return -t
         return l / r
 
+class Neg(Term):
 
-class Neg(Term):
     def __init__(self, term: Term):
         self.term = term
 
@@ -41,10 +45,10 @@
         t = self.term.evaluate()
         return -t
 
+class Constant(Term):
 
-class Constant(Term):
     def __init__(self, value: int):
         self.value = value
 
     def evaluate(self) -> float | int:
-        return self.value
+        return self.value

____________________________________________________________________________________________________

GeneticCandidate@tmp/expression_1(12)[0.08]
Found 1 equivalent patches.
Mutations: [InsertBoth(37,15)]

---------- Evaluation Matrix ----------
STILL PASSING: [46/50]
NOW FAILING: [4/50]
NOW PASSING: [0/50]
STILL FAILING: [50/50]
PRECISION: 0.0
RECALL: 0.0
ACCURACY: 0.46
F1 SCORE: 0.0
---------------------------------------
--- src/expression/expr/arithmetic.py
+++ src/expression/expr/arithmetic.py
@@ -1,39 +1,41 @@
 class Term:
+
     def evaluate(self) -> float | int:
         pass
 
+class Binary(Term):
 
-class Binary(Term):
     def __init__(self, left: Term, right: Term):
         self.left = left
         self.right = right
 
+class Add(Binary):
 
-class Add(Binary):
     def evaluate(self):
-        l, r = self.left.evaluate(), self.right.evaluate()
+        l, r = (self.left.evaluate(), self.right.evaluate())
         return l + r
 
+class Sub(Binary):
 
-class Sub(Binary):
     def evaluate(self):
-        l, r = self.left.evaluate(), self.right.evaluate()
+        l, r = (self.left.evaluate(), self.right.evaluate())
         return l - r
 
+class Mul(Binary):
 
-class Mul(Binary):
     def evaluate(self):
-        l, r = self.left.evaluate(), self.right.evaluate()
+        l, r = (self.left.evaluate(), self.right.evaluate())
         return l * r
 
+class Div(Binary):
 
-class Div(Binary):
     def evaluate(self):
-        l, r = self.left.evaluate(), self.right.evaluate()
+        main()
+        l, r = (self.left.evaluate(), self.right.evaluate())
         return l / r
 
+class Neg(Term):
 
-class Neg(Term):
     def __init__(self, term: Term):
         self.term = term
 
@@ -41,10 +43,10 @@
         t = self.term.evaluate()
         return -t
 
+class Constant(Term):
 
-class Constant(Term):
     def __init__(self, value: int):
         self.value = value
 
     def evaluate(self) -> float | int:
-        return self.value
+        return self.value

____________________________________________________________________________________________________

GeneticCandidate@tmp/expression_1(10)[0.08]
Found 1 equivalent patches.
Mutations: [Delete(37)]

---------- Evaluation Matrix ----------
STILL PASSING: [46/50]
NOW FAILING: [4/50]
NOW PASSING: [0/50]
STILL FAILING: [50/50]
PRECISION: 0.0
RECALL: 0.0
ACCURACY: 0.46
F1 SCORE: 0.0
---------------------------------------
--- src/expression/expr/arithmetic.py
+++ src/expression/expr/arithmetic.py
@@ -1,39 +1,40 @@
 class Term:
+
     def evaluate(self) -> float | int:
         pass
 
+class Binary(Term):
 
-class Binary(Term):
     def __init__(self, left: Term, right: Term):
         self.left = left
         self.right = right
 
+class Add(Binary):
 
-class Add(Binary):
     def evaluate(self):
-        l, r = self.left.evaluate(), self.right.evaluate()
+        l, r = (self.left.evaluate(), self.right.evaluate())
         return l + r
 
+class Sub(Binary):
 
-class Sub(Binary):
     def evaluate(self):
-        l, r = self.left.evaluate(), self.right.evaluate()
+        l, r = (self.left.evaluate(), self.right.evaluate())
         return l - r
 
+class Mul(Binary):
 
-class Mul(Binary):
     def evaluate(self):
-        l, r = self.left.evaluate(), self.right.evaluate()
+        l, r = (self.left.evaluate(), self.right.evaluate())
         return l * r
 
+class Div(Binary):
 
-class Div(Binary):
     def evaluate(self):
-        l, r = self.left.evaluate(), self.right.evaluate()
+        pass
         return l / r
 
+class Neg(Term):
 
-class Neg(Term):
     def __init__(self, term: Term):
         self.term = term
 
@@ -41,10 +42,10 @@
         t = self.term.evaluate()
         return -t
 
+class Constant(Term):
 
-class Constant(Term):
     def __init__(self, value: int):
         self.value = value
 
     def evaluate(self) -> float | int:
-        return self.value
+        return self.value

____________________________________________________________________________________________________

GeneticCandidate@tmp/expression_1(10)[0.08]
Found 1 equivalent patches.
Mutations: [Replace(38,22)]

---------- Evaluation Matrix ----------
STILL PASSING: [46/50]
NOW FAILING: [4/50]
NOW PASSING: [0/50]
STILL FAILING: [50/50]
PRECISION: 0.0
RECALL: 0.0
ACCURACY: 0.46
F1 SCORE: 0.0
---------------------------------------
--- src/expression/expr/arithmetic.py
+++ src/expression/expr/arithmetic.py
@@ -1,39 +1,40 @@
 class Term:
+
     def evaluate(self) -> float | int:
         pass
 
+class Binary(Term):
 
-class Binary(Term):
     def __init__(self, left: Term, right: Term):
         self.left = left
         self.right = right
 
+class Add(Binary):
 
-class Add(Binary):
     def evaluate(self):
-        l, r = self.left.evaluate(), self.right.evaluate()
+        l, r = (self.left.evaluate(), self.right.evaluate())
         return l + r
 
+class Sub(Binary):
 
-class Sub(Binary):
     def evaluate(self):
-        l, r = self.left.evaluate(), self.right.evaluate()
+        l, r = (self.left.evaluate(), self.right.evaluate())
         return l - r
 
+class Mul(Binary):
 
-class Mul(Binary):
     def evaluate(self):
-        l, r = self.left.evaluate(), self.right.evaluate()
+        l, r = (self.left.evaluate(), self.right.evaluate())
         return l * r
 
+class Div(Binary):
 
-class Div(Binary):
     def evaluate(self):
-        l, r = self.left.evaluate(), self.right.evaluate()
-        return l / r
-
+        l, r = (self.left.evaluate(), self.right.evaluate())
+        self.right = right
 
 class Neg(Term):
+
     def __init__(self, term: Term):
         self.term = term
 
@@ -41,10 +42,10 @@
         t = self.term.evaluate()
         return -t
 
+class Constant(Term):
 
-class Constant(Term):
     def __init__(self, value: int):
         self.value = value
 
     def evaluate(self) -> float | int:
-        return self.value
+        return self.value

____________________________________________________________________________________________________

GeneticCandidate@tmp/expression_1(8)[0.07]
Found 1 equivalent patches.
Mutations: [Replace(93,16)]

---------- Evaluation Matrix ----------
STILL PASSING: [38/50]
NOW FAILING: [12/50]
NOW PASSING: [0/50]
STILL FAILING: [50/50]
PRECISION: 0.0
RECALL: 0.0
ACCURACY: 0.38
F1 SCORE: 0.0
---------------------------------------
--- src/expression/expr/parse.py
+++ src/expression/expr/parse.py
@@ -1,71 +1,60 @@
 from typing import List
-
-# noinspection PyUnresolvedReferences
-from expression.expr.arithmetic import (
-    Constant,
-    Term,
-    Add,
-    Neg,
-    Sub,
-    Mul,
-    Div,
-)
-
+from expression.expr.arithmetic import Constant, Term, Add, Neg, Sub, Mul, Div
 
 def parse(s: str):
-    s = s.replace("(", " ( ")
-    s = s.replace(")", " ) ")
-    while "  " in s:
-        s = s.replace("  ", " ")
+    s = s.replace('(', ' ( ')
+    s = s.replace(')', ' ) ')
+    while '  ' in s:
+        s = s.replace('  ', ' ')
     s = s.strip()
-    tokens = list(reversed(s.split(" ")))
+    tokens = list(reversed(s.split(' ')))
     assert tokens
     term = parse_add_sub(tokens)
     assert not tokens
     return term
 
-
 def parse_terminal(tokens) -> Term:
     token = tokens.pop(0)
     if token.isnumeric():
         return Constant(int(token))
-    elif token == ")":
+    elif token == ')':
         term = parse_add_sub(tokens)
         token = tokens.pop(0)
-        assert token == "("
+        assert token == '('
         return term
     else:
         assert False
 
-
 def parse_neg(tokens) -> Term:
     term = parse_terminal(tokens)
-    if tokens and tokens[0] in "~":
+    if tokens and tokens[0] in '~':
         tokens.pop(0)
         return Neg(term)
     else:
         return term
 
-
 def parse_mul_div(tokens: List[str]) -> Term:
     term = parse_neg(tokens)
-    if tokens and tokens[0] in "*/":
+    if tokens and tokens[0] in '*/':
         token = tokens.pop(0)
-        if token == "*":
+        if token == '*':
             return Mul(parse_mul_div(tokens), term)
         else:
             return Div(parse_mul_div(tokens), term)
     else:
         return term
 
-
 def parse_add_sub(tokens: List[str]) -> Term:
     term = parse_mul_div(tokens)
-    if tokens and tokens[0] in "+-":
+    if tokens and tokens[0] in '+-':
         token = tokens.pop(0)
-        if token == "+":
+        if token == '+':
             return Add(parse_add_sub(tokens), term)
         else:
-            return Sub(parse_add_sub(tokens), term)
+
+            class Term:
+
+                def evaluate(self) -> float | int:
+                    pass
     else:
-        return term
+        return term

____________________________________________________________________________________________________

GeneticCandidate@tmp/expression_1(11)[0.07]
Found 5 equivalent patches.
Mutations: [Replace(93,18)]

---------- Evaluation Matrix ----------
STILL PASSING: [38/50]
NOW FAILING: [12/50]
NOW PASSING: [0/50]
STILL FAILING: [50/50]
PRECISION: 0.0
RECALL: 0.0
ACCURACY: 0.38
F1 SCORE: 0.0
---------------------------------------
--- src/expression/expr/parse.py
+++ src/expression/expr/parse.py
@@ -1,71 +1,56 @@
 from typing import List
-
-# noinspection PyUnresolvedReferences
-from expression.expr.arithmetic import (
-    Constant,
-    Term,
-    Add,
-    Neg,
-    Sub,
-    Mul,
-    Div,
-)
-
+from expression.expr.arithmetic import Constant, Term, Add, Neg, Sub, Mul, Div
 
 def parse(s: str):
-    s = s.replace("(", " ( ")
-    s = s.replace(")", " ) ")
-    while "  " in s:
-        s = s.replace("  ", " ")
+    s = s.replace('(', ' ( ')
+    s = s.replace(')', ' ) ')
+    while '  ' in s:
+        s = s.replace('  ', ' ')
     s = s.strip()
-    tokens = list(reversed(s.split(" ")))
+    tokens = list(reversed(s.split(' ')))
     assert tokens
     term = parse_add_sub(tokens)
     assert not tokens
     return term
 
-
 def parse_terminal(tokens) -> Term:
     token = tokens.pop(0)
     if token.isnumeric():
         return Constant(int(token))
-    elif token == ")":
+    elif token == ')':
         term = parse_add_sub(tokens)
         token = tokens.pop(0)
-        assert token == "("
+        assert token == '('
         return term
     else:
         assert False
 
-
 def parse_neg(tokens) -> Term:
     term = parse_terminal(tokens)
-    if tokens and tokens[0] in "~":
+    if tokens and tokens[0] in '~':
         tokens.pop(0)
         return Neg(term)
     else:
         return term
 
-
 def parse_mul_div(tokens: List[str]) -> Term:
     term = parse_neg(tokens)
-    if tokens and tokens[0] in "*/":
+    if tokens and tokens[0] in '*/':
         token = tokens.pop(0)
-        if token == "*":
+        if token == '*':
             return Mul(parse_mul_div(tokens), term)
         else:
             return Div(parse_mul_div(tokens), term)
     else:
         return term
 
-
 def parse_add_sub(tokens: List[str]) -> Term:
     term = parse_mul_div(tokens)
-    if tokens and tokens[0] in "+-":
+    if tokens and tokens[0] in '+-':
         token = tokens.pop(0)
-        if token == "+":
+        if token == '+':
             return Add(parse_add_sub(tokens), term)
         else:
-            return Sub(parse_add_sub(tokens), term)
+            pass
     else:
-        return term
+        return term

____________________________________________________________________________________________________

GeneticCandidate@tmp/expression_1(8)[0.07]
Found 1 equivalent patches.
Mutations: [InsertBoth(30,59)]

---------- Evaluation Matrix ----------
STILL PASSING: [38/50]
NOW FAILING: [12/50]
NOW PASSING: [0/50]
STILL FAILING: [50/50]
PRECISION: 0.0
RECALL: 0.0
ACCURACY: 0.38
F1 SCORE: 0.0
---------------------------------------
--- src/expression/expr/arithmetic.py
+++ src/expression/expr/arithmetic.py
@@ -1,39 +1,41 @@
 class Term:
+
     def evaluate(self) -> float | int:
         pass
 
+class Binary(Term):
 
-class Binary(Term):
     def __init__(self, left: Term, right: Term):
         self.left = left
         self.right = right
 
+class Add(Binary):
 
-class Add(Binary):
     def evaluate(self):
-        l, r = self.left.evaluate(), self.right.evaluate()
+        l, r = (self.left.evaluate(), self.right.evaluate())
         return l + r
 
+class Sub(Binary):
 
-class Sub(Binary):
     def evaluate(self):
-        l, r = self.left.evaluate(), self.right.evaluate()
+        l, r = (self.left.evaluate(), self.right.evaluate())
+        assert tokens
         return l - r
 
+class Mul(Binary):
 
-class Mul(Binary):
     def evaluate(self):
-        l, r = self.left.evaluate(), self.right.evaluate()
+        l, r = (self.left.evaluate(), self.right.evaluate())
         return l * r
 
+class Div(Binary):
 
-class Div(Binary):
     def evaluate(self):
-        l, r = self.left.evaluate(), self.right.evaluate()
+        l, r = (self.left.evaluate(), self.right.evaluate())
         return l / r
 
+class Neg(Term):
 
-class Neg(Term):
     def __init__(self, term: Term):
         self.term = term
 
@@ -41,10 +43,10 @@
         t = self.term.evaluate()
         return -t
 
+class Constant(Term):
 
-class Constant(Term):
     def __init__(self, value: int):
         self.value = value
 
     def evaluate(self) -> float | int:
-        return self.value
+        return self.value

____________________________________________________________________________________________________

GeneticCandidate@tmp/expression_1(10)[0.06]
Found 4 equivalent patches.
Mutations: [Delete(82)]

---------- Evaluation Matrix ----------
STILL PASSING: [34/50]
NOW FAILING: [16/50]
NOW PASSING: [0/50]
STILL FAILING: [50/50]
PRECISION: 0.0
RECALL: 0.0
ACCURACY: 0.34
F1 SCORE: 0.0
---------------------------------------
--- src/expression/expr/parse.py
+++ src/expression/expr/parse.py
@@ -1,71 +1,56 @@
 from typing import List
-
-# noinspection PyUnresolvedReferences
-from expression.expr.arithmetic import (
-    Constant,
-    Term,
-    Add,
-    Neg,
-    Sub,
-    Mul,
-    Div,
-)
-
+from expression.expr.arithmetic import Constant, Term, Add, Neg, Sub, Mul, Div
 
 def parse(s: str):
-    s = s.replace("(", " ( ")
-    s = s.replace(")", " ) ")
-    while "  " in s:
-        s = s.replace("  ", " ")
+    s = s.replace('(', ' ( ')
+    s = s.replace(')', ' ) ')
+    while '  ' in s:
+        s = s.replace('  ', ' ')
     s = s.strip()
-    tokens = list(reversed(s.split(" ")))
+    tokens = list(reversed(s.split(' ')))
     assert tokens
     term = parse_add_sub(tokens)
     assert not tokens
     return term
 
-
 def parse_terminal(tokens) -> Term:
     token = tokens.pop(0)
     if token.isnumeric():
         return Constant(int(token))
-    elif token == ")":
+    elif token == ')':
         term = parse_add_sub(tokens)
         token = tokens.pop(0)
-        assert token == "("
+        assert token == '('
         return term
     else:
         assert False
 
-
 def parse_neg(tokens) -> Term:
     term = parse_terminal(tokens)
-    if tokens and tokens[0] in "~":
+    if tokens and tokens[0] in '~':
         tokens.pop(0)
         return Neg(term)
     else:
         return term
 
-
 def parse_mul_div(tokens: List[str]) -> Term:
     term = parse_neg(tokens)
-    if tokens and tokens[0] in "*/":
-        token = tokens.pop(0)
-        if token == "*":
+    if tokens and tokens[0] in '*/':
+        pass
+        if token == '*':
             return Mul(parse_mul_div(tokens), term)
         else:
             return Div(parse_mul_div(tokens), term)
     else:
         return term
 
-
 def parse_add_sub(tokens: List[str]) -> Term:
     term = parse_mul_div(tokens)
-    if tokens and tokens[0] in "+-":
+    if tokens and tokens[0] in '+-':
         token = tokens.pop(0)
-        if token == "+":
+        if token == '+':
             return Add(parse_add_sub(tokens), term)
         else:
             return Sub(parse_add_sub(tokens), term)
     else:
-        return term
+        return term

____________________________________________________________________________________________________

GeneticCandidate@tmp/expression_1(8)[0.06]
Found 6 equivalent patches.
Mutations: [InsertBoth(82,74)]

---------- Evaluation Matrix ----------
STILL PASSING: [34/50]
NOW FAILING: [16/50]
NOW PASSING: [0/50]
STILL FAILING: [50/50]
PRECISION: 0.0
RECALL: 0.0
ACCURACY: 0.34
F1 SCORE: 0.0
---------------------------------------
--- src/expression/expr/parse.py
+++ src/expression/expr/parse.py
@@ -1,71 +1,57 @@
 from typing import List
-
-# noinspection PyUnresolvedReferences
-from expression.expr.arithmetic import (
-    Constant,
-    Term,
-    Add,
-    Neg,
-    Sub,
-    Mul,
-    Div,
-)
-
+from expression.expr.arithmetic import Constant, Term, Add, Neg, Sub, Mul, Div
 
 def parse(s: str):
-    s = s.replace("(", " ( ")
-    s = s.replace(")", " ) ")
-    while "  " in s:
-        s = s.replace("  ", " ")
+    s = s.replace('(', ' ( ')
+    s = s.replace(')', ' ) ')
+    while '  ' in s:
+        s = s.replace('  ', ' ')
     s = s.strip()
-    tokens = list(reversed(s.split(" ")))
+    tokens = list(reversed(s.split(' ')))
     assert tokens
     term = parse_add_sub(tokens)
     assert not tokens
     return term
 
-
 def parse_terminal(tokens) -> Term:
     token = tokens.pop(0)
     if token.isnumeric():
         return Constant(int(token))
-    elif token == ")":
+    elif token == ')':
         term = parse_add_sub(tokens)
         token = tokens.pop(0)
-        assert token == "("
+        assert token == '('
         return term
     else:
         assert False
 
-
 def parse_neg(tokens) -> Term:
     term = parse_terminal(tokens)
-    if tokens and tokens[0] in "~":
+    if tokens and tokens[0] in '~':
         tokens.pop(0)
         return Neg(term)
     else:
         return term
 
-
 def parse_mul_div(tokens: List[str]) -> Term:
     term = parse_neg(tokens)
-    if tokens and tokens[0] in "*/":
+    if tokens and tokens[0] in '*/':
         token = tokens.pop(0)
-        if token == "*":
+        term = parse_terminal(tokens)
+        if token == '*':
             return Mul(parse_mul_div(tokens), term)
         else:
             return Div(parse_mul_div(tokens), term)
     else:
         return term
 
-
 def parse_add_sub(tokens: List[str]) -> Term:
     term = parse_mul_div(tokens)
-    if tokens and tokens[0] in "+-":
+    if tokens and tokens[0] in '+-':
         token = tokens.pop(0)
-        if token == "+":
+        if token == '+':
             return Add(parse_add_sub(tokens), term)
         else:
             return Sub(parse_add_sub(tokens), term)
     else:
-        return term
+        return term

____________________________________________________________________________________________________

GeneticCandidate@tmp/expression_1(10)[0.06]
Found 1 equivalent patches.
Mutations: [Replace(83,18)]

---------- Evaluation Matrix ----------
STILL PASSING: [34/50]
NOW FAILING: [16/50]
NOW PASSING: [0/50]
STILL FAILING: [50/50]
PRECISION: 0.0
RECALL: 0.0
ACCURACY: 0.34
F1 SCORE: 0.0
---------------------------------------
--- src/expression/expr/parse.py
+++ src/expression/expr/parse.py
@@ -1,71 +1,53 @@
 from typing import List
-
-# noinspection PyUnresolvedReferences
-from expression.expr.arithmetic import (
-    Constant,
-    Term,
-    Add,
-    Neg,
-    Sub,
-    Mul,
-    Div,
-)
-
+from expression.expr.arithmetic import Constant, Term, Add, Neg, Sub, Mul, Div
 
 def parse(s: str):
-    s = s.replace("(", " ( ")
-    s = s.replace(")", " ) ")
-    while "  " in s:
-        s = s.replace("  ", " ")
+    s = s.replace('(', ' ( ')
+    s = s.replace(')', ' ) ')
+    while '  ' in s:
+        s = s.replace('  ', ' ')
     s = s.strip()
-    tokens = list(reversed(s.split(" ")))
+    tokens = list(reversed(s.split(' ')))
     assert tokens
     term = parse_add_sub(tokens)
     assert not tokens
     return term
 
-
 def parse_terminal(tokens) -> Term:
     token = tokens.pop(0)
     if token.isnumeric():
         return Constant(int(token))
-    elif token == ")":
+    elif token == ')':
         term = parse_add_sub(tokens)
         token = tokens.pop(0)
-        assert token == "("
+        assert token == '('
         return term
     else:
         assert False
 
-
 def parse_neg(tokens) -> Term:
     term = parse_terminal(tokens)
-    if tokens and tokens[0] in "~":
+    if tokens and tokens[0] in '~':
         tokens.pop(0)
         return Neg(term)
     else:
         return term
 
-
 def parse_mul_div(tokens: List[str]) -> Term:
     term = parse_neg(tokens)
-    if tokens and tokens[0] in "*/":
+    if tokens and tokens[0] in '*/':
         token = tokens.pop(0)
-        if token == "*":
-            return Mul(parse_mul_div(tokens), term)
-        else:
-            return Div(parse_mul_div(tokens), term)
+        pass
     else:
         return term
 
-
 def parse_add_sub(tokens: List[str]) -> Term:
     term = parse_mul_div(tokens)
-    if tokens and tokens[0] in "+-":
+    if tokens and tokens[0] in '+-':
         token = tokens.pop(0)
-        if token == "+":
+        if token == '+':
             return Add(parse_add_sub(tokens), term)
         else:
             return Sub(parse_add_sub(tokens), term)
     else:
-        return term
+        return term

____________________________________________________________________________________________________

GeneticCandidate@tmp/expression_1(10)[0.06]
Found 2 equivalent patches.
Mutations: [InsertBoth(82,72)]

---------- Evaluation Matrix ----------
STILL PASSING: [34/50]
NOW FAILING: [16/50]
NOW PASSING: [0/50]
STILL FAILING: [50/50]
PRECISION: 0.0
RECALL: 0.0
ACCURACY: 0.34
F1 SCORE: 0.0
---------------------------------------
--- src/expression/expr/parse.py
+++ src/expression/expr/parse.py
@@ -1,71 +1,57 @@
 from typing import List
-
-# noinspection PyUnresolvedReferences
-from expression.expr.arithmetic import (
-    Constant,
-    Term,
-    Add,
-    Neg,
-    Sub,
-    Mul,
-    Div,
-)
-
+from expression.expr.arithmetic import Constant, Term, Add, Neg, Sub, Mul, Div
 
 def parse(s: str):
-    s = s.replace("(", " ( ")
-    s = s.replace(")", " ) ")
-    while "  " in s:
-        s = s.replace("  ", " ")
+    s = s.replace('(', ' ( ')
+    s = s.replace(')', ' ) ')
+    while '  ' in s:
+        s = s.replace('  ', ' ')
     s = s.strip()
-    tokens = list(reversed(s.split(" ")))
+    tokens = list(reversed(s.split(' ')))
     assert tokens
     term = parse_add_sub(tokens)
     assert not tokens
     return term
 
-
 def parse_terminal(tokens) -> Term:
     token = tokens.pop(0)
     if token.isnumeric():
         return Constant(int(token))
-    elif token == ")":
+    elif token == ')':
         term = parse_add_sub(tokens)
         token = tokens.pop(0)
-        assert token == "("
+        assert token == '('
         return term
     else:
         assert False
 
-
 def parse_neg(tokens) -> Term:
     term = parse_terminal(tokens)
-    if tokens and tokens[0] in "~":
+    if tokens and tokens[0] in '~':
         tokens.pop(0)
         return Neg(term)
     else:
         return term
 
-
 def parse_mul_div(tokens: List[str]) -> Term:
     term = parse_neg(tokens)
-    if tokens and tokens[0] in "*/":
+    if tokens and tokens[0] in '*/':
+        assert False
         token = tokens.pop(0)
-        if token == "*":
+        if token == '*':
             return Mul(parse_mul_div(tokens), term)
         else:
             return Div(parse_mul_div(tokens), term)
     else:
         return term
 
-
 def parse_add_sub(tokens: List[str]) -> Term:
     term = parse_mul_div(tokens)
-    if tokens and tokens[0] in "+-":
+    if tokens and tokens[0] in '+-':
         token = tokens.pop(0)
-        if token == "+":
+        if token == '+':
             return Add(parse_add_sub(tokens), term)
         else:
             return Sub(parse_add_sub(tokens), term)
     else:
-        return term
+        return term

____________________________________________________________________________________________________

GeneticCandidate@tmp/expression_1(8)[0.06]
Found 2 equivalent patches.
Mutations: [InsertBoth(83,10)]

---------- Evaluation Matrix ----------
STILL PASSING: [34/50]
NOW FAILING: [16/50]
NOW PASSING: [0/50]
STILL FAILING: [50/50]
PRECISION: 0.0
RECALL: 0.0
ACCURACY: 0.34
F1 SCORE: 0.0
---------------------------------------
--- src/expression/expr/parse.py
+++ src/expression/expr/parse.py
@@ -1,71 +1,57 @@
 from typing import List
-
-# noinspection PyUnresolvedReferences
-from expression.expr.arithmetic import (
-    Constant,
-    Term,
-    Add,
-    Neg,
-    Sub,
-    Mul,
-    Div,
-)
-
+from expression.expr.arithmetic import Constant, Term, Add, Neg, Sub, Mul, Div
 
 def parse(s: str):
-    s = s.replace("(", " ( ")
-    s = s.replace(")", " ) ")
-    while "  " in s:
-        s = s.replace("  ", " ")
+    s = s.replace('(', ' ( ')
+    s = s.replace(')', ' ) ')
+    while '  ' in s:
+        s = s.replace('  ', ' ')
     s = s.strip()
-    tokens = list(reversed(s.split(" ")))
+    tokens = list(reversed(s.split(' ')))
     assert tokens
     term = parse_add_sub(tokens)
     assert not tokens
     return term
 
-
 def parse_terminal(tokens) -> Term:
     token = tokens.pop(0)
     if token.isnumeric():
         return Constant(int(token))
-    elif token == ")":
+    elif token == ')':
         term = parse_add_sub(tokens)
         token = tokens.pop(0)
-        assert token == "("
+        assert token == '('
         return term
     else:
         assert False
 
-
 def parse_neg(tokens) -> Term:
     term = parse_terminal(tokens)
-    if tokens and tokens[0] in "~":
+    if tokens and tokens[0] in '~':
         tokens.pop(0)
         return Neg(term)
     else:
         return term
 
-
 def parse_mul_div(tokens: List[str]) -> Term:
     term = parse_neg(tokens)
-    if tokens and tokens[0] in "*/":
+    if tokens and tokens[0] in '*/':
         token = tokens.pop(0)
-        if token == "*":
+        sys.stderr = stderr
+        if token == '*':
             return Mul(parse_mul_div(tokens), term)
         else:
             return Div(parse_mul_div(tokens), term)
     else:
         return term
 
-
 def parse_add_sub(tokens: List[str]) -> Term:
     term = parse_mul_div(tokens)
-    if tokens and tokens[0] in "+-":
+    if tokens and tokens[0] in '+-':
         token = tokens.pop(0)
-        if token == "+":
+        if token == '+':
             return Add(parse_add_sub(tokens), term)
         else:
             return Sub(parse_add_sub(tokens), term)
     else:
-        return term
+        return term

____________________________________________________________________________________________________

GeneticCandidate@tmp/expression_1(9)[0.06]
Found 1 equivalent patches.
Mutations: [InsertBoth(82,86)]

---------- Evaluation Matrix ----------
STILL PASSING: [34/50]
NOW FAILING: [16/50]
NOW PASSING: [0/50]
STILL FAILING: [50/50]
PRECISION: 0.0
RECALL: 0.0
ACCURACY: 0.34
F1 SCORE: 0.0
---------------------------------------
--- src/expression/expr/parse.py
+++ src/expression/expr/parse.py
@@ -1,71 +1,57 @@
 from typing import List
-
-# noinspection PyUnresolvedReferences
-from expression.expr.arithmetic import (
-    Constant,
-    Term,
-    Add,
-    Neg,
-    Sub,
-    Mul,
-    Div,
-)
-
+from expression.expr.arithmetic import Constant, Term, Add, Neg, Sub, Mul, Div
 
 def parse(s: str):
-    s = s.replace("(", " ( ")
-    s = s.replace(")", " ) ")
-    while "  " in s:
-        s = s.replace("  ", " ")
+    s = s.replace('(', ' ( ')
+    s = s.replace(')', ' ) ')
+    while '  ' in s:
+        s = s.replace('  ', ' ')
     s = s.strip()
-    tokens = list(reversed(s.split(" ")))
+    tokens = list(reversed(s.split(' ')))
     assert tokens
     term = parse_add_sub(tokens)
     assert not tokens
     return term
 
-
 def parse_terminal(tokens) -> Term:
     token = tokens.pop(0)
     if token.isnumeric():
         return Constant(int(token))
-    elif token == ")":
+    elif token == ')':
         term = parse_add_sub(tokens)
         token = tokens.pop(0)
-        assert token == "("
+        assert token == '('
         return term
     else:
         assert False
 
-
 def parse_neg(tokens) -> Term:
     term = parse_terminal(tokens)
-    if tokens and tokens[0] in "~":
+    if tokens and tokens[0] in '~':
         tokens.pop(0)
         return Neg(term)
     else:
         return term
 
-
 def parse_mul_div(tokens: List[str]) -> Term:
     term = parse_neg(tokens)
-    if tokens and tokens[0] in "*/":
+    if tokens and tokens[0] in '*/':
         token = tokens.pop(0)
-        if token == "*":
+        return term
+        if token == '*':
             return Mul(parse_mul_div(tokens), term)
         else:
             return Div(parse_mul_div(tokens), term)
     else:
         return term
 
-
 def parse_add_sub(tokens: List[str]) -> Term:
     term = parse_mul_div(tokens)
-    if tokens and tokens[0] in "+-":
+    if tokens and tokens[0] in '+-':
         token = tokens.pop(0)
-        if token == "+":
+        if token == '+':
             return Add(parse_add_sub(tokens), term)
         else:
             return Sub(parse_add_sub(tokens), term)
     else:
-        return term
+        return term

____________________________________________________________________________________________________

GeneticCandidate@tmp/expression_1(10)[0.06]
Found 1 equivalent patches.
Mutations: [Replace(82,50)]

---------- Evaluation Matrix ----------
STILL PASSING: [34/50]
NOW FAILING: [16/50]
NOW PASSING: [0/50]
STILL FAILING: [50/50]
PRECISION: 0.0
RECALL: 0.0
ACCURACY: 0.34
F1 SCORE: 0.0
---------------------------------------
--- src/expression/expr/parse.py
+++ src/expression/expr/parse.py
@@ -1,71 +1,56 @@
 from typing import List
-
-# noinspection PyUnresolvedReferences
-from expression.expr.arithmetic import (
-    Constant,
-    Term,
-    Add,
-    Neg,
-    Sub,
-    Mul,
-    Div,
-)
-
+from expression.expr.arithmetic import Constant, Term, Add, Neg, Sub, Mul, Div
 
 def parse(s: str):
-    s = s.replace("(", " ( ")
-    s = s.replace(")", " ) ")
-    while "  " in s:
-        s = s.replace("  ", " ")
+    s = s.replace('(', ' ( ')
+    s = s.replace(')', ' ) ')
+    while '  ' in s:
+        s = s.replace('  ', ' ')
     s = s.strip()
-    tokens = list(reversed(s.split(" ")))
+    tokens = list(reversed(s.split(' ')))
     assert tokens
     term = parse_add_sub(tokens)
     assert not tokens
     return term
 
-
 def parse_terminal(tokens) -> Term:
     token = tokens.pop(0)
     if token.isnumeric():
         return Constant(int(token))
-    elif token == ")":
+    elif token == ')':
         term = parse_add_sub(tokens)
         token = tokens.pop(0)
-        assert token == "("
+        assert token == '('
         return term
     else:
         assert False
 
-
 def parse_neg(tokens) -> Term:
     term = parse_terminal(tokens)
-    if tokens and tokens[0] in "~":
+    if tokens and tokens[0] in '~':
         tokens.pop(0)
         return Neg(term)
     else:
         return term
 
-
 def parse_mul_div(tokens: List[str]) -> Term:
     term = parse_neg(tokens)
-    if tokens and tokens[0] in "*/":
-        token = tokens.pop(0)
-        if token == "*":
+    if tokens and tokens[0] in '*/':
+        from typing import List
+        if token == '*':
             return Mul(parse_mul_div(tokens), term)
         else:
             return Div(parse_mul_div(tokens), term)
     else:
         return term
 
-
 def parse_add_sub(tokens: List[str]) -> Term:
     term = parse_mul_div(tokens)
-    if tokens and tokens[0] in "+-":
+    if tokens and tokens[0] in '+-':
         token = tokens.pop(0)
-        if token == "+":
+        if token == '+':
             return Add(parse_add_sub(tokens), term)
         else:
             return Sub(parse_add_sub(tokens), term)
     else:
-        return term
+        return term

____________________________________________________________________________________________________

