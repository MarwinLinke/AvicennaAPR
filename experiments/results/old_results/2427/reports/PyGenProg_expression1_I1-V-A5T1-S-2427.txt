APPROACH: PyGenProg
SUBJECT: expression_1
Used 1 failing and 10 passing test cases from Tests4py in the fault localization
Used 5 failing and 5 passing test cases from Avicenna in the validation
In total 11 for fault localization and 10 for validation.
The gathering of test cases took 3.6854 seconds.
The repair ran for 421.0481 seconds.
The evaluation took 696.3638 seconds.
Was a valid patch found: False
BEST FITNESS: 0.09090909090909091
BEST F1 SCORE: 0.0
Found a total of 39 patches.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

PATCHES (SORTED):
GeneticCandidate@tmp/expression_1(2)[0.09]
---------- Evaluation Matrix ----------
STILL PASSING: [50/50]
NOW FAILING: [0/50]
NOW PASSING: [0/50]
STILL FAILING: [50/50]
PRECISION: 0.0
RECALL: 0.0
ACCURACY: 0.5
F1 SCORE: 0.0
---------------------------------------
--- src/expression/expr/arithmetic.py
+++ src/expression/expr/arithmetic.py
@@ -1,39 +1,40 @@
 class Term:
+
     def evaluate(self) -> float | int:
         pass
 
+class Binary(Term):
 
-class Binary(Term):
     def __init__(self, left: Term, right: Term):
         self.left = left
         self.right = right
 
+class Add(Binary):
 
-class Add(Binary):
     def evaluate(self):
-        l, r = self.left.evaluate(), self.right.evaluate()
+        l, r = (self.left.evaluate(), self.right.evaluate())
         return l + r
 
+class Sub(Binary):
 
-class Sub(Binary):
     def evaluate(self):
-        l, r = self.left.evaluate(), self.right.evaluate()
+        l, r = (self.left.evaluate(), self.right.evaluate())
         return l - r
 
+class Mul(Binary):
 
-class Mul(Binary):
     def evaluate(self):
-        l, r = self.left.evaluate(), self.right.evaluate()
+        l, r = (self.left.evaluate(), self.right.evaluate())
         return l * r
 
+class Div(Binary):
 
-class Div(Binary):
     def evaluate(self):
-        l, r = self.left.evaluate(), self.right.evaluate()
+        l, r = (self.left.evaluate(), self.right.evaluate())
         return l / r
 
+class Neg(Term):
 
-class Neg(Term):
     def __init__(self, term: Term):
         self.term = term
 
@@ -41,10 +42,11 @@
         t = self.term.evaluate()
         return -t
 
+class Constant(Term):
 
-class Constant(Term):
     def __init__(self, value: int):
         self.value = value
 
     def evaluate(self) -> float | int:
-        return self.value
+        from typing import List
+        return self.value

____________________________________________________________________________________________________

GeneticCandidate@tmp/expression_1(1)[0.09]
---------- Evaluation Matrix ----------
STILL PASSING: [50/50]
NOW FAILING: [0/50]
NOW PASSING: [0/50]
STILL FAILING: [50/50]
PRECISION: 0.0
RECALL: 0.0
ACCURACY: 0.5
F1 SCORE: 0.0
---------------------------------------
--- src/expression/expr/parse.py
+++ src/expression/expr/parse.py
@@ -1,71 +1,60 @@
 from typing import List
-
-# noinspection PyUnresolvedReferences
-from expression.expr.arithmetic import (
-    Constant,
-    Term,
-    Add,
-    Neg,
-    Sub,
-    Mul,
-    Div,
-)
-
+from expression.expr.arithmetic import Constant, Term, Add, Neg, Sub, Mul, Div
 
 def parse(s: str):
-    s = s.replace("(", " ( ")
-    s = s.replace(")", " ) ")
-    while "  " in s:
-        s = s.replace("  ", " ")
+    s = s.replace('(', ' ( ')
+    s = s.replace(')', ' ) ')
+
+    def evaluate(self):
+        l, r = (self.left.evaluate(), self.right.evaluate())
+        return l * r
+    while '  ' in s:
+        s = s.replace('  ', ' ')
     s = s.strip()
-    tokens = list(reversed(s.split(" ")))
+    tokens = list(reversed(s.split(' ')))
     assert tokens
     term = parse_add_sub(tokens)
     assert not tokens
     return term
 
-
 def parse_terminal(tokens) -> Term:
     token = tokens.pop(0)
     if token.isnumeric():
         return Constant(int(token))
-    elif token == ")":
+    elif token == ')':
         term = parse_add_sub(tokens)
         token = tokens.pop(0)
-        assert token == "("
+        assert token == '('
         return term
     else:
         assert False
 
-
 def parse_neg(tokens) -> Term:
     term = parse_terminal(tokens)
-    if tokens and tokens[0] in "~":
+    if tokens and tokens[0] in '~':
         tokens.pop(0)
         return Neg(term)
     else:
         return term
 
-
 def parse_mul_div(tokens: List[str]) -> Term:
     term = parse_neg(tokens)
-    if tokens and tokens[0] in "*/":
+    if tokens and tokens[0] in '*/':
         token = tokens.pop(0)
-        if token == "*":
+        if token == '*':
             return Mul(parse_mul_div(tokens), term)
         else:
             return Div(parse_mul_div(tokens), term)
     else:
         return term
 
-
 def parse_add_sub(tokens: List[str]) -> Term:
     term = parse_mul_div(tokens)
-    if tokens and tokens[0] in "+-":
+    if tokens and tokens[0] in '+-':
         token = tokens.pop(0)
-        if token == "+":
+        if token == '+':
             return Add(parse_add_sub(tokens), term)
         else:
             return Sub(parse_add_sub(tokens), term)
     else:
-        return term
+        return term

____________________________________________________________________________________________________

GeneticCandidate@tmp/expression_1(2)[0.09]
---------- Evaluation Matrix ----------
STILL PASSING: [50/50]
NOW FAILING: [0/50]
NOW PASSING: [0/50]
STILL FAILING: [50/50]
PRECISION: 0.0
RECALL: 0.0
ACCURACY: 0.5
F1 SCORE: 0.0
---------------------------------------
--- src/expression/expr/arithmetic.py
+++ src/expression/expr/arithmetic.py
@@ -1,39 +1,42 @@
 class Term:
+
     def evaluate(self) -> float | int:
-        pass
 
+        def evaluate(self) -> float | int:
+            return self.value
 
 class Binary(Term):
+
     def __init__(self, left: Term, right: Term):
         self.left = left
         self.right = right
 
+class Add(Binary):
 
-class Add(Binary):
     def evaluate(self):
-        l, r = self.left.evaluate(), self.right.evaluate()
+        l, r = (self.left.evaluate(), self.right.evaluate())
         return l + r
 
+class Sub(Binary):
 
-class Sub(Binary):
     def evaluate(self):
-        l, r = self.left.evaluate(), self.right.evaluate()
+        l, r = (self.left.evaluate(), self.right.evaluate())
         return l - r
 
+class Mul(Binary):
 
-class Mul(Binary):
     def evaluate(self):
-        l, r = self.left.evaluate(), self.right.evaluate()
+        l, r = (self.left.evaluate(), self.right.evaluate())
         return l * r
 
+class Div(Binary):
 
-class Div(Binary):
     def evaluate(self):
-        l, r = self.left.evaluate(), self.right.evaluate()
+        l, r = (self.left.evaluate(), self.right.evaluate())
         return l / r
 
+class Neg(Term):
 
-class Neg(Term):
     def __init__(self, term: Term):
         self.term = term
 
@@ -41,10 +44,10 @@
         t = self.term.evaluate()
         return -t
 
+class Constant(Term):
 
-class Constant(Term):
     def __init__(self, value: int):
         self.value = value
 
     def evaluate(self) -> float | int:
-        return self.value
+        return self.value

____________________________________________________________________________________________________

GeneticCandidate@tmp/expression_1(1)[0.09]
---------- Evaluation Matrix ----------
STILL PASSING: [50/50]
NOW FAILING: [0/50]
NOW PASSING: [0/50]
STILL FAILING: [50/50]
PRECISION: 0.0
RECALL: 0.0
ACCURACY: 0.5
F1 SCORE: 0.0
---------------------------------------
--- src/expression/expr/parse.py
+++ src/expression/expr/parse.py
@@ -1,71 +1,56 @@
 from typing import List
-
-# noinspection PyUnresolvedReferences
-from expression.expr.arithmetic import (
-    Constant,
-    Term,
-    Add,
-    Neg,
-    Sub,
-    Mul,
-    Div,
-)
-
+from expression.expr.arithmetic import Constant, Term, Add, Neg, Sub, Mul, Div
 
 def parse(s: str):
-    s = s.replace("(", " ( ")
-    s = s.replace(")", " ) ")
-    while "  " in s:
-        s = s.replace("  ", " ")
+    s = s.replace('(', ' ( ')
+    s = s.replace(')', ' ) ')
+    while '  ' in s:
+        s = s.replace('  ', ' ')
     s = s.strip()
-    tokens = list(reversed(s.split(" ")))
+    tokens = list(reversed(s.split(' ')))
     assert tokens
     term = parse_add_sub(tokens)
     assert not tokens
     return term
 
-
 def parse_terminal(tokens) -> Term:
     token = tokens.pop(0)
     if token.isnumeric():
         return Constant(int(token))
-    elif token == ")":
+    elif token == ')':
         term = parse_add_sub(tokens)
         token = tokens.pop(0)
-        assert token == "("
+        assert token == '('
         return term
     else:
-        assert False
-
+        pass
 
 def parse_neg(tokens) -> Term:
     term = parse_terminal(tokens)
-    if tokens and tokens[0] in "~":
+    if tokens and tokens[0] in '~':
         tokens.pop(0)
         return Neg(term)
     else:
         return term
 
-
 def parse_mul_div(tokens: List[str]) -> Term:
     term = parse_neg(tokens)
-    if tokens and tokens[0] in "*/":
+    if tokens and tokens[0] in '*/':
         token = tokens.pop(0)
-        if token == "*":
+        if token == '*':
             return Mul(parse_mul_div(tokens), term)
         else:
             return Div(parse_mul_div(tokens), term)
     else:
         return term
 
-
 def parse_add_sub(tokens: List[str]) -> Term:
     term = parse_mul_div(tokens)
-    if tokens and tokens[0] in "+-":
+    if tokens and tokens[0] in '+-':
         token = tokens.pop(0)
-        if token == "+":
+        if token == '+':
             return Add(parse_add_sub(tokens), term)
         else:
             return Sub(parse_add_sub(tokens), term)
     else:
-        return term
+        return term

____________________________________________________________________________________________________

GeneticCandidate@tmp/expression_1(1)[0.09]
---------- Evaluation Matrix ----------
STILL PASSING: [50/50]
NOW FAILING: [0/50]
NOW PASSING: [0/50]
STILL FAILING: [50/50]
PRECISION: 0.0
RECALL: 0.0
ACCURACY: 0.5
F1 SCORE: 0.0
---------------------------------------
--- src/expression/expr/arithmetic.py
+++ src/expression/expr/arithmetic.py
@@ -1,39 +1,40 @@
 class Term:
+
     def evaluate(self) -> float | int:
         pass
 
+class Binary(Term):
 
-class Binary(Term):
     def __init__(self, left: Term, right: Term):
         self.left = left
         self.right = right
 
+class Add(Binary):
 
-class Add(Binary):
     def evaluate(self):
-        l, r = self.left.evaluate(), self.right.evaluate()
+        l, r = (self.left.evaluate(), self.right.evaluate())
         return l + r
 
+class Sub(Binary):
 
-class Sub(Binary):
     def evaluate(self):
-        l, r = self.left.evaluate(), self.right.evaluate()
+        l, r = (self.left.evaluate(), self.right.evaluate())
         return l - r
 
+class Mul(Binary):
 
-class Mul(Binary):
     def evaluate(self):
-        l, r = self.left.evaluate(), self.right.evaluate()
+        l, r = (self.left.evaluate(), self.right.evaluate())
         return l * r
 
+class Div(Binary):
 
-class Div(Binary):
     def evaluate(self):
-        l, r = self.left.evaluate(), self.right.evaluate()
+        l, r = (self.left.evaluate(), self.right.evaluate())
         return l / r
 
+class Neg(Term):
 
-class Neg(Term):
     def __init__(self, term: Term):
         self.term = term
 
@@ -41,10 +42,16 @@
         t = self.term.evaluate()
         return -t
 
+class Constant(Term):
 
-class Constant(Term):
     def __init__(self, value: int):
+
+        class Mul(Binary):
+
+            def evaluate(self):
+                l, r = (self.left.evaluate(), self.right.evaluate())
+                return l * r
         self.value = value
 
     def evaluate(self) -> float | int:
-        return self.value
+        return self.value

____________________________________________________________________________________________________

GeneticCandidate@tmp/expression_1(1)[0.09]
---------- Evaluation Matrix ----------
STILL PASSING: [50/50]
NOW FAILING: [0/50]
NOW PASSING: [0/50]
STILL FAILING: [50/50]
PRECISION: 0.0
RECALL: 0.0
ACCURACY: 0.5
F1 SCORE: 0.0
---------------------------------------
--- src/expression/expr/parse.py
+++ src/expression/expr/parse.py
@@ -1,71 +1,60 @@
 from typing import List
-
-# noinspection PyUnresolvedReferences
-from expression.expr.arithmetic import (
-    Constant,
-    Term,
-    Add,
-    Neg,
-    Sub,
-    Mul,
-    Div,
-)
-
+from expression.expr.arithmetic import Constant, Term, Add, Neg, Sub, Mul, Div
 
 def parse(s: str):
-    s = s.replace("(", " ( ")
-    s = s.replace(")", " ) ")
-    while "  " in s:
-        s = s.replace("  ", " ")
+    s = s.replace('(', ' ( ')
+    s = s.replace(')', ' ) ')
+    while '  ' in s:
+        s = s.replace('  ', ' ')
     s = s.strip()
-    tokens = list(reversed(s.split(" ")))
+    tokens = list(reversed(s.split(' ')))
     assert tokens
     term = parse_add_sub(tokens)
     assert not tokens
     return term
 
-
 def parse_terminal(tokens) -> Term:
     token = tokens.pop(0)
     if token.isnumeric():
         return Constant(int(token))
-    elif token == ")":
+    elif token == ')':
         term = parse_add_sub(tokens)
         token = tokens.pop(0)
-        assert token == "("
+        assert token == '('
         return term
     else:
         assert False
 
-
 def parse_neg(tokens) -> Term:
     term = parse_terminal(tokens)
-    if tokens and tokens[0] in "~":
+    if tokens and tokens[0] in '~':
         tokens.pop(0)
         return Neg(term)
     else:
         return term
 
-
 def parse_mul_div(tokens: List[str]) -> Term:
     term = parse_neg(tokens)
-    if tokens and tokens[0] in "*/":
+    if tokens and tokens[0] in '*/':
         token = tokens.pop(0)
-        if token == "*":
+
+        def evaluate(self):
+            l, r = (self.left.evaluate(), self.right.evaluate())
+            return l + r
+        if token == '*':
             return Mul(parse_mul_div(tokens), term)
         else:
             return Div(parse_mul_div(tokens), term)
     else:
         return term
 
-
 def parse_add_sub(tokens: List[str]) -> Term:
     term = parse_mul_div(tokens)
-    if tokens and tokens[0] in "+-":
+    if tokens and tokens[0] in '+-':
         token = tokens.pop(0)
-        if token == "+":
+        if token == '+':
             return Add(parse_add_sub(tokens), term)
         else:
             return Sub(parse_add_sub(tokens), term)
     else:
-        return term
+        return term

____________________________________________________________________________________________________

GeneticCandidate@tmp/expression_1(2)[0.09]
---------- Evaluation Matrix ----------
STILL PASSING: [50/50]
NOW FAILING: [0/50]
NOW PASSING: [0/50]
STILL FAILING: [50/50]
PRECISION: 0.0
RECALL: 0.0
ACCURACY: 0.5
F1 SCORE: 0.0
---------------------------------------
--- src/expression/expr/arithmetic.py
+++ src/expression/expr/arithmetic.py
@@ -1,39 +1,41 @@
 class Term:
+
     def evaluate(self) -> float | int:
         pass
 
+class Binary(Term):
 
-class Binary(Term):
     def __init__(self, left: Term, right: Term):
         self.left = left
         self.right = right
 
+class Add(Binary):
 
-class Add(Binary):
     def evaluate(self):
-        l, r = self.left.evaluate(), self.right.evaluate()
+        l, r = (self.left.evaluate(), self.right.evaluate())
         return l + r
 
+class Sub(Binary):
 
-class Sub(Binary):
     def evaluate(self):
-        l, r = self.left.evaluate(), self.right.evaluate()
+        l, r = (self.left.evaluate(), self.right.evaluate())
         return l - r
 
+class Mul(Binary):
 
-class Mul(Binary):
     def evaluate(self):
-        l, r = self.left.evaluate(), self.right.evaluate()
+        l, r = (self.left.evaluate(), self.right.evaluate())
         return l * r
 
+class Div(Binary):
 
-class Div(Binary):
     def evaluate(self):
-        l, r = self.left.evaluate(), self.right.evaluate()
+        l, r = (self.left.evaluate(), self.right.evaluate())
+        l, r = (self.left.evaluate(), self.right.evaluate())
         return l / r
 
+class Neg(Term):
 
-class Neg(Term):
     def __init__(self, term: Term):
         self.term = term
 
@@ -41,10 +43,10 @@
         t = self.term.evaluate()
         return -t
 
+class Constant(Term):
 
-class Constant(Term):
     def __init__(self, value: int):
         self.value = value
 
     def evaluate(self) -> float | int:
-        return self.value
+        return self.value

____________________________________________________________________________________________________

GeneticCandidate@tmp/expression_1(1)[0.09]
---------- Evaluation Matrix ----------
STILL PASSING: [50/50]
NOW FAILING: [0/50]
NOW PASSING: [0/50]
STILL FAILING: [50/50]
PRECISION: 0.0
RECALL: 0.0
ACCURACY: 0.5
F1 SCORE: 0.0
---------------------------------------
--- src/expression/expr/parse.py
+++ src/expression/expr/parse.py
@@ -1,71 +1,56 @@
 from typing import List
-
-# noinspection PyUnresolvedReferences
-from expression.expr.arithmetic import (
-    Constant,
-    Term,
-    Add,
-    Neg,
-    Sub,
-    Mul,
-    Div,
-)
-
+from expression.expr.arithmetic import Constant, Term, Add, Neg, Sub, Mul, Div
 
 def parse(s: str):
-    s = s.replace("(", " ( ")
-    s = s.replace(")", " ) ")
-    while "  " in s:
-        s = s.replace("  ", " ")
+    s = s.replace('(', ' ( ')
+    s = s.replace(')', ' ) ')
+    while '  ' in s:
+        s = s.replace('  ', ' ')
     s = s.strip()
-    tokens = list(reversed(s.split(" ")))
+    tokens = list(reversed(s.split(' ')))
     assert tokens
     term = parse_add_sub(tokens)
     assert not tokens
     return term
 
-
 def parse_terminal(tokens) -> Term:
     token = tokens.pop(0)
     if token.isnumeric():
         return Constant(int(token))
-    elif token == ")":
+    elif token == ')':
         term = parse_add_sub(tokens)
         token = tokens.pop(0)
-        assert token == "("
+        assert token == '('
         return term
     else:
         assert False
 
-
 def parse_neg(tokens) -> Term:
     term = parse_terminal(tokens)
-    if tokens and tokens[0] in "~":
+    if tokens and tokens[0] in '~':
         tokens.pop(0)
         return Neg(term)
     else:
         return term
 
-
 def parse_mul_div(tokens: List[str]) -> Term:
     term = parse_neg(tokens)
-    if tokens and tokens[0] in "*/":
+    if tokens and tokens[0] in '*/':
         token = tokens.pop(0)
-        if token == "*":
+        if token == '*':
             return Mul(parse_mul_div(tokens), term)
         else:
             return Div(parse_mul_div(tokens), term)
     else:
         return term
 
-
 def parse_add_sub(tokens: List[str]) -> Term:
     term = parse_mul_div(tokens)
-    if tokens and tokens[0] in "+-":
+    if tokens and tokens[0] in '+-':
         token = tokens.pop(0)
-        if token == "+":
+        if token == '+':
             return Add(parse_add_sub(tokens), term)
         else:
             return Sub(parse_add_sub(tokens), term)
     else:
-        return term
+        return term

____________________________________________________________________________________________________

GeneticCandidate@tmp/expression_1(2)[0.09]
---------- Evaluation Matrix ----------
STILL PASSING: [50/50]
NOW FAILING: [0/50]
NOW PASSING: [0/50]
STILL FAILING: [50/50]
PRECISION: 0.0
RECALL: 0.0
ACCURACY: 0.5
F1 SCORE: 0.0
---------------------------------------
--- src/expression/expr/parse.py
+++ src/expression/expr/parse.py
@@ -1,71 +1,56 @@
 from typing import List
-
-# noinspection PyUnresolvedReferences
-from expression.expr.arithmetic import (
-    Constant,
-    Term,
-    Add,
-    Neg,
-    Sub,
-    Mul,
-    Div,
-)
-
+from expression.expr.arithmetic import Constant, Term, Add, Neg, Sub, Mul, Div
 
 def parse(s: str):
-    s = s.replace("(", " ( ")
-    s = s.replace(")", " ) ")
-    while "  " in s:
-        s = s.replace("  ", " ")
+    s = s.replace('(', ' ( ')
+    s = s.replace(')', ' ) ')
+    while '  ' in s:
+        s = s.replace('  ', ' ')
     s = s.strip()
-    tokens = list(reversed(s.split(" ")))
+    tokens = list(reversed(s.split(' ')))
     assert tokens
     term = parse_add_sub(tokens)
     assert not tokens
     return term
 
-
 def parse_terminal(tokens) -> Term:
     token = tokens.pop(0)
     if token.isnumeric():
         return Constant(int(token))
-    elif token == ")":
+    elif token == ')':
         term = parse_add_sub(tokens)
         token = tokens.pop(0)
-        assert token == "("
+        assert token == '('
         return term
     else:
         assert False
 
-
 def parse_neg(tokens) -> Term:
     term = parse_terminal(tokens)
-    if tokens and tokens[0] in "~":
+    if tokens and tokens[0] in '~':
         tokens.pop(0)
         return Neg(term)
     else:
         return term
 
-
 def parse_mul_div(tokens: List[str]) -> Term:
     term = parse_neg(tokens)
-    if tokens and tokens[0] in "*/":
+    if tokens and tokens[0] in '*/':
         token = tokens.pop(0)
-        if token == "*":
+        if token == '*':
             return Mul(parse_mul_div(tokens), term)
         else:
             return Div(parse_mul_div(tokens), term)
     else:
         return term
 
-
 def parse_add_sub(tokens: List[str]) -> Term:
     term = parse_mul_div(tokens)
-    if tokens and tokens[0] in "+-":
+    if tokens and tokens[0] in '+-':
         token = tokens.pop(0)
-        if token == "+":
+        if token == '+':
             return Add(parse_add_sub(tokens), term)
         else:
             return Sub(parse_add_sub(tokens), term)
     else:
-        return term
+        return term

____________________________________________________________________________________________________

GeneticCandidate@tmp/expression_1(2)[0.09]
---------- Evaluation Matrix ----------
STILL PASSING: [50/50]
NOW FAILING: [0/50]
NOW PASSING: [0/50]
STILL FAILING: [50/50]
PRECISION: 0.0
RECALL: 0.0
ACCURACY: 0.5
F1 SCORE: 0.0
---------------------------------------
--- src/expression/expr/parse.py
+++ src/expression/expr/parse.py
@@ -1,71 +1,57 @@
 from typing import List
-
-# noinspection PyUnresolvedReferences
-from expression.expr.arithmetic import (
-    Constant,
-    Term,
-    Add,
-    Neg,
-    Sub,
-    Mul,
-    Div,
-)
-
+from expression.expr.arithmetic import Constant, Term, Add, Neg, Sub, Mul, Div
 
 def parse(s: str):
-    s = s.replace("(", " ( ")
-    s = s.replace(")", " ) ")
-    while "  " in s:
-        s = s.replace("  ", " ")
+    s = s.replace('(', ' ( ')
+    s = s.replace(')', ' ) ')
+    while '  ' in s:
+        s = s.replace('  ', ' ')
     s = s.strip()
-    tokens = list(reversed(s.split(" ")))
+    tokens = list(reversed(s.split(' ')))
     assert tokens
     term = parse_add_sub(tokens)
     assert not tokens
     return term
 
-
 def parse_terminal(tokens) -> Term:
     token = tokens.pop(0)
     if token.isnumeric():
         return Constant(int(token))
-    elif token == ")":
+    elif token == ')':
         term = parse_add_sub(tokens)
         token = tokens.pop(0)
-        assert token == "("
+        assert token == '('
         return term
     else:
         assert False
 
-
 def parse_neg(tokens) -> Term:
     term = parse_terminal(tokens)
-    if tokens and tokens[0] in "~":
+    if tokens and tokens[0] in '~':
         tokens.pop(0)
         return Neg(term)
     else:
         return term
 
-
 def parse_mul_div(tokens: List[str]) -> Term:
     term = parse_neg(tokens)
-    if tokens and tokens[0] in "*/":
+    if tokens and tokens[0] in '*/':
         token = tokens.pop(0)
-        if token == "*":
+        if token == '*':
             return Mul(parse_mul_div(tokens), term)
         else:
             return Div(parse_mul_div(tokens), term)
+            return l * r
     else:
         return term
 
-
 def parse_add_sub(tokens: List[str]) -> Term:
     term = parse_mul_div(tokens)
-    if tokens and tokens[0] in "+-":
+    if tokens and tokens[0] in '+-':
         token = tokens.pop(0)
-        if token == "+":
+        if token == '+':
             return Add(parse_add_sub(tokens), term)
         else:
             return Sub(parse_add_sub(tokens), term)
     else:
-        return term
+        return term

____________________________________________________________________________________________________

GeneticCandidate@tmp/expression_1(0)[0.09]
---------- Evaluation Matrix ----------
STILL PASSING: [50/50]
NOW FAILING: [0/50]
NOW PASSING: [0/50]
STILL FAILING: [50/50]
PRECISION: 0.0
RECALL: 0.0
ACCURACY: 0.5
F1 SCORE: 0.0
---------------------------------------
Patch could not be printed.

____________________________________________________________________________________________________

GeneticCandidate@tmp/expression_1(2)[0.08]
---------- Evaluation Matrix ----------
STILL PASSING: [43/50]
NOW FAILING: [7/50]
NOW PASSING: [0/50]
STILL FAILING: [50/50]
PRECISION: 0.0
RECALL: 0.0
ACCURACY: 0.43
F1 SCORE: 0.0
---------------------------------------
--- src/expression/expr/parse.py
+++ src/expression/expr/parse.py
@@ -1,71 +1,56 @@
 from typing import List
-
-# noinspection PyUnresolvedReferences
-from expression.expr.arithmetic import (
-    Constant,
-    Term,
-    Add,
-    Neg,
-    Sub,
-    Mul,
-    Div,
-)
-
+from expression.expr.arithmetic import Constant, Term, Add, Neg, Sub, Mul, Div
 
 def parse(s: str):
-    s = s.replace("(", " ( ")
-    s = s.replace(")", " ) ")
-    while "  " in s:
-        s = s.replace("  ", " ")
+    s = s.replace('(', ' ( ')
+    s = s.replace(')', ' ) ')
+    while '  ' in s:
+        s = s.replace('  ', ' ')
     s = s.strip()
-    tokens = list(reversed(s.split(" ")))
+    tokens = list(reversed(s.split(' ')))
     assert tokens
     term = parse_add_sub(tokens)
     assert not tokens
     return term
 
-
 def parse_terminal(tokens) -> Term:
     token = tokens.pop(0)
     if token.isnumeric():
         return Constant(int(token))
-    elif token == ")":
+    elif token == ')':
         term = parse_add_sub(tokens)
         token = tokens.pop(0)
-        assert token == "("
+        assert token == '('
         return term
     else:
         assert False
 
-
 def parse_neg(tokens) -> Term:
     term = parse_terminal(tokens)
-    if tokens and tokens[0] in "~":
+    if tokens and tokens[0] in '~':
         tokens.pop(0)
         return Neg(term)
     else:
         return term
 
-
 def parse_mul_div(tokens: List[str]) -> Term:
     term = parse_neg(tokens)
-    if tokens and tokens[0] in "*/":
+    if tokens and tokens[0] in '*/':
         token = tokens.pop(0)
-        if token == "*":
+        if token == '*':
             return Mul(parse_mul_div(tokens), term)
         else:
-            return Div(parse_mul_div(tokens), term)
+            l, r = (self.left.evaluate(), self.right.evaluate())
     else:
         return term
 
-
 def parse_add_sub(tokens: List[str]) -> Term:
     term = parse_mul_div(tokens)
-    if tokens and tokens[0] in "+-":
+    if tokens and tokens[0] in '+-':
         token = tokens.pop(0)
-        if token == "+":
+        if token == '+':
             return Add(parse_add_sub(tokens), term)
         else:
             return Sub(parse_add_sub(tokens), term)
     else:
-        return term
+        return term

____________________________________________________________________________________________________

GeneticCandidate@tmp/expression_1(2)[0.07]
---------- Evaluation Matrix ----------
STILL PASSING: [37/50]
NOW FAILING: [13/50]
NOW PASSING: [0/50]
STILL FAILING: [50/50]
PRECISION: 0.0
RECALL: 0.0
ACCURACY: 0.37
F1 SCORE: 0.0
---------------------------------------
--- src/expression/expr/arithmetic.py
+++ src/expression/expr/arithmetic.py
@@ -1,39 +1,40 @@
 class Term:
+
     def evaluate(self) -> float | int:
         pass
 
+class Binary(Term):
 
-class Binary(Term):
     def __init__(self, left: Term, right: Term):
         self.left = left
         self.right = right
 
+class Add(Binary):
 
-class Add(Binary):
     def evaluate(self):
-        l, r = self.left.evaluate(), self.right.evaluate()
+        pass
         return l + r
 
+class Sub(Binary):
 
-class Sub(Binary):
     def evaluate(self):
-        l, r = self.left.evaluate(), self.right.evaluate()
+        l, r = (self.left.evaluate(), self.right.evaluate())
         return l - r
 
+class Mul(Binary):
 
-class Mul(Binary):
     def evaluate(self):
-        l, r = self.left.evaluate(), self.right.evaluate()
+        l, r = (self.left.evaluate(), self.right.evaluate())
         return l * r
 
+class Div(Binary):
 
-class Div(Binary):
     def evaluate(self):
-        l, r = self.left.evaluate(), self.right.evaluate()
+        l, r = (self.left.evaluate(), self.right.evaluate())
         return l / r
 
+class Neg(Term):
 
-class Neg(Term):
     def __init__(self, term: Term):
         self.term = term
 
@@ -41,10 +42,10 @@
         t = self.term.evaluate()
         return -t
 
+class Constant(Term):
 
-class Constant(Term):
     def __init__(self, value: int):
         self.value = value
 
     def evaluate(self) -> float | int:
-        return self.value
+        return self.value

____________________________________________________________________________________________________

GeneticCandidate@tmp/expression_1(1)[0.06]
---------- Evaluation Matrix ----------
STILL PASSING: [35/50]
NOW FAILING: [15/50]
NOW PASSING: [0/50]
STILL FAILING: [50/50]
PRECISION: 0.0
RECALL: 0.0
ACCURACY: 0.35
F1 SCORE: 0.0
---------------------------------------
--- src/expression/expr/arithmetic.py
+++ src/expression/expr/arithmetic.py
@@ -1,39 +1,40 @@
 class Term:
+
     def evaluate(self) -> float | int:
         pass
 
+class Binary(Term):
 
-class Binary(Term):
     def __init__(self, left: Term, right: Term):
         self.left = left
         self.right = right
 
+class Add(Binary):
 
-class Add(Binary):
     def evaluate(self):
-        l, r = self.left.evaluate(), self.right.evaluate()
+        l, r = (self.left.evaluate(), self.right.evaluate())
         return l + r
 
+class Sub(Binary):
 
-class Sub(Binary):
     def evaluate(self):
-        l, r = self.left.evaluate(), self.right.evaluate()
+        l, r = (self.left.evaluate(), self.right.evaluate())
         return l - r
 
+class Mul(Binary):
 
-class Mul(Binary):
     def evaluate(self):
-        l, r = self.left.evaluate(), self.right.evaluate()
+        args = args or sys.argv[1:]
         return l * r
 
+class Div(Binary):
 
-class Div(Binary):
     def evaluate(self):
-        l, r = self.left.evaluate(), self.right.evaluate()
+        l, r = (self.left.evaluate(), self.right.evaluate())
         return l / r
 
+class Neg(Term):
 
-class Neg(Term):
     def __init__(self, term: Term):
         self.term = term
 
@@ -41,10 +42,10 @@
         t = self.term.evaluate()
         return -t
 
+class Constant(Term):
 
-class Constant(Term):
     def __init__(self, value: int):
         self.value = value
 
     def evaluate(self) -> float | int:
-        return self.value
+        return self.value

____________________________________________________________________________________________________

GeneticCandidate@tmp/expression_1(2)[0.06]
---------- Evaluation Matrix ----------
STILL PASSING: [33/50]
NOW FAILING: [17/50]
NOW PASSING: [0/50]
STILL FAILING: [50/50]
PRECISION: 0.0
RECALL: 0.0
ACCURACY: 0.33
F1 SCORE: 0.0
---------------------------------------
--- src/expression/expr/parse.py
+++ src/expression/expr/parse.py
@@ -1,71 +1,63 @@
 from typing import List
-
-# noinspection PyUnresolvedReferences
-from expression.expr.arithmetic import (
-    Constant,
-    Term,
-    Add,
-    Neg,
-    Sub,
-    Mul,
-    Div,
-)
-
+from expression.expr.arithmetic import Constant, Term, Add, Neg, Sub, Mul, Div
 
 def parse(s: str):
-    s = s.replace("(", " ( ")
-    s = s.replace(")", " ) ")
-    while "  " in s:
-        s = s.replace("  ", " ")
+    s = s.replace('(', ' ( ')
+    s = s.replace(')', ' ) ')
+    while '  ' in s:
+        s = s.replace('  ', ' ')
     s = s.strip()
-    tokens = list(reversed(s.split(" ")))
+    tokens = list(reversed(s.split(' ')))
     assert tokens
     term = parse_add_sub(tokens)
     assert not tokens
     return term
 
-
 def parse_terminal(tokens) -> Term:
     token = tokens.pop(0)
     if token.isnumeric():
         return Constant(int(token))
-    elif token == ")":
+    elif token == ')':
         term = parse_add_sub(tokens)
         token = tokens.pop(0)
-        assert token == "("
+        assert token == '('
         return term
     else:
         assert False
 
-
 def parse_neg(tokens) -> Term:
     term = parse_terminal(tokens)
-    if tokens and tokens[0] in "~":
+    if tokens and tokens[0] in '~':
         tokens.pop(0)
         return Neg(term)
     else:
         return term
 
-
 def parse_mul_div(tokens: List[str]) -> Term:
     term = parse_neg(tokens)
-    if tokens and tokens[0] in "*/":
-        token = tokens.pop(0)
-        if token == "*":
+    if tokens and tokens[0] in '*/':
+
+        class Constant(Term):
+
+            def __init__(self, value: int):
+                self.value = value
+
+            def evaluate(self) -> float | int:
+                return self.value
+        if token == '*':
             return Mul(parse_mul_div(tokens), term)
         else:
             return Div(parse_mul_div(tokens), term)
     else:
         return term
 
-
 def parse_add_sub(tokens: List[str]) -> Term:
     term = parse_mul_div(tokens)
-    if tokens and tokens[0] in "+-":
+    if tokens and tokens[0] in '+-':
         token = tokens.pop(0)
-        if token == "+":
+        if token == '+':
             return Add(parse_add_sub(tokens), term)
         else:
             return Sub(parse_add_sub(tokens), term)
     else:
-        return term
+        return term

____________________________________________________________________________________________________

GeneticCandidate@tmp/expression_1(1)[0.06]
---------- Evaluation Matrix ----------
STILL PASSING: [33/50]
NOW FAILING: [17/50]
NOW PASSING: [0/50]
STILL FAILING: [50/50]
PRECISION: 0.0
RECALL: 0.0
ACCURACY: 0.33
F1 SCORE: 0.0
---------------------------------------
--- src/expression/expr/parse.py
+++ src/expression/expr/parse.py
@@ -1,71 +1,57 @@
 from typing import List
-
-# noinspection PyUnresolvedReferences
-from expression.expr.arithmetic import (
-    Constant,
-    Term,
-    Add,
-    Neg,
-    Sub,
-    Mul,
-    Div,
-)
-
+from expression.expr.arithmetic import Constant, Term, Add, Neg, Sub, Mul, Div
 
 def parse(s: str):
-    s = s.replace("(", " ( ")
-    s = s.replace(")", " ) ")
-    while "  " in s:
-        s = s.replace("  ", " ")
+    s = s.replace('(', ' ( ')
+    s = s.replace(')', ' ) ')
+    while '  ' in s:
+        s = s.replace('  ', ' ')
     s = s.strip()
-    tokens = list(reversed(s.split(" ")))
+    tokens = list(reversed(s.split(' ')))
     assert tokens
     term = parse_add_sub(tokens)
     assert not tokens
     return term
 
-
 def parse_terminal(tokens) -> Term:
     token = tokens.pop(0)
     if token.isnumeric():
         return Constant(int(token))
-    elif token == ")":
+    elif token == ')':
         term = parse_add_sub(tokens)
         token = tokens.pop(0)
-        assert token == "("
+        assert token == '('
         return term
     else:
         assert False
 
-
 def parse_neg(tokens) -> Term:
     term = parse_terminal(tokens)
-    if tokens and tokens[0] in "~":
+    if tokens and tokens[0] in '~':
         tokens.pop(0)
         return Neg(term)
     else:
         return term
 
-
 def parse_mul_div(tokens: List[str]) -> Term:
     term = parse_neg(tokens)
-    if tokens and tokens[0] in "*/":
+    if tokens and tokens[0] in '*/':
         token = tokens.pop(0)
-        if token == "*":
+        term = parse_neg(tokens)
+        if token == '*':
             return Mul(parse_mul_div(tokens), term)
         else:
             return Div(parse_mul_div(tokens), term)
     else:
         return term
 
-
 def parse_add_sub(tokens: List[str]) -> Term:
     term = parse_mul_div(tokens)
-    if tokens and tokens[0] in "+-":
+    if tokens and tokens[0] in '+-':
         token = tokens.pop(0)
-        if token == "+":
+        if token == '+':
             return Add(parse_add_sub(tokens), term)
         else:
             return Sub(parse_add_sub(tokens), term)
     else:
-        return term
+        return term

____________________________________________________________________________________________________

GeneticCandidate@tmp/expression_1(2)[0.05]
---------- Evaluation Matrix ----------
STILL PASSING: [27/50]
NOW FAILING: [23/50]
NOW PASSING: [0/50]
STILL FAILING: [50/50]
PRECISION: 0.0
RECALL: 0.0
ACCURACY: 0.27
F1 SCORE: 0.0
---------------------------------------
--- src/expression/expr/parse.py
+++ src/expression/expr/parse.py
@@ -1,71 +1,53 @@
 from typing import List
-
-# noinspection PyUnresolvedReferences
-from expression.expr.arithmetic import (
-    Constant,
-    Term,
-    Add,
-    Neg,
-    Sub,
-    Mul,
-    Div,
-)
-
+from expression.expr.arithmetic import Constant, Term, Add, Neg, Sub, Mul, Div
 
 def parse(s: str):
-    s = s.replace("(", " ( ")
-    s = s.replace(")", " ) ")
-    while "  " in s:
-        s = s.replace("  ", " ")
+    s = s.replace('(', ' ( ')
+    s = s.replace(')', ' ) ')
+    while '  ' in s:
+        s = s.replace('  ', ' ')
     s = s.strip()
-    tokens = list(reversed(s.split(" ")))
+    tokens = list(reversed(s.split(' ')))
     assert tokens
     term = parse_add_sub(tokens)
     assert not tokens
     return term
 
-
 def parse_terminal(tokens) -> Term:
     token = tokens.pop(0)
     if token.isnumeric():
         return Constant(int(token))
-    elif token == ")":
+    elif token == ')':
         term = parse_add_sub(tokens)
         token = tokens.pop(0)
-        assert token == "("
+        assert token == '('
         return term
     else:
         assert False
 
-
 def parse_neg(tokens) -> Term:
     term = parse_terminal(tokens)
-    if tokens and tokens[0] in "~":
+    if tokens and tokens[0] in '~':
         tokens.pop(0)
         return Neg(term)
     else:
         return term
 
-
 def parse_mul_div(tokens: List[str]) -> Term:
     term = parse_neg(tokens)
-    if tokens and tokens[0] in "*/":
+    if tokens and tokens[0] in '*/':
         token = tokens.pop(0)
-        if token == "*":
+        if token == '*':
             return Mul(parse_mul_div(tokens), term)
         else:
             return Div(parse_mul_div(tokens), term)
     else:
         return term
 
-
 def parse_add_sub(tokens: List[str]) -> Term:
     term = parse_mul_div(tokens)
-    if tokens and tokens[0] in "+-":
+    if tokens and tokens[0] in '+-':
         token = tokens.pop(0)
-        if token == "+":
-            return Add(parse_add_sub(tokens), term)
-        else:
-            return Sub(parse_add_sub(tokens), term)
+        args = args or sys.argv[1:]
     else:
-        return term
+        return term

____________________________________________________________________________________________________

GeneticCandidate@tmp/expression_1(2)[0.05]
---------- Evaluation Matrix ----------
STILL PASSING: [25/50]
NOW FAILING: [25/50]
NOW PASSING: [0/50]
STILL FAILING: [50/50]
PRECISION: 0.0
RECALL: 0.0
ACCURACY: 0.25
F1 SCORE: 0.0
---------------------------------------
--- src/expression/expr/parse.py
+++ src/expression/expr/parse.py
@@ -1,71 +1,56 @@
 from typing import List
-
-# noinspection PyUnresolvedReferences
-from expression.expr.arithmetic import (
-    Constant,
-    Term,
-    Add,
-    Neg,
-    Sub,
-    Mul,
-    Div,
-)
-
+from expression.expr.arithmetic import Constant, Term, Add, Neg, Sub, Mul, Div
 
 def parse(s: str):
-    s = s.replace("(", " ( ")
-    s = s.replace(")", " ) ")
-    while "  " in s:
-        s = s.replace("  ", " ")
+    s = s.replace('(', ' ( ')
+    s = s.replace(')', ' ) ')
+    while '  ' in s:
+        s = s.replace('  ', ' ')
     s = s.strip()
-    tokens = list(reversed(s.split(" ")))
+    tokens = list(reversed(s.split(' ')))
     assert tokens
     term = parse_add_sub(tokens)
     assert not tokens
     return term
 
-
 def parse_terminal(tokens) -> Term:
     token = tokens.pop(0)
     if token.isnumeric():
         return Constant(int(token))
-    elif token == ")":
+    elif token == ')':
         term = parse_add_sub(tokens)
         token = tokens.pop(0)
-        assert token == "("
+        assert token == '('
         return term
     else:
         assert False
 
-
 def parse_neg(tokens) -> Term:
     term = parse_terminal(tokens)
-    if tokens and tokens[0] in "~":
-        tokens.pop(0)
+    if tokens and tokens[0] in '~':
+        result = term.evaluate()
         return Neg(term)
     else:
         return term
 
-
 def parse_mul_div(tokens: List[str]) -> Term:
     term = parse_neg(tokens)
-    if tokens and tokens[0] in "*/":
+    if tokens and tokens[0] in '*/':
         token = tokens.pop(0)
-        if token == "*":
+        if token == '*':
             return Mul(parse_mul_div(tokens), term)
         else:
             return Div(parse_mul_div(tokens), term)
     else:
         return term
 
-
 def parse_add_sub(tokens: List[str]) -> Term:
     term = parse_mul_div(tokens)
-    if tokens and tokens[0] in "+-":
+    if tokens and tokens[0] in '+-':
         token = tokens.pop(0)
-        if token == "+":
+        if token == '+':
             return Add(parse_add_sub(tokens), term)
         else:
             return Sub(parse_add_sub(tokens), term)
     else:
-        return term
+        return term

____________________________________________________________________________________________________

GeneticCandidate@tmp/expression_1(2)[0.05]
---------- Evaluation Matrix ----------
STILL PASSING: [25/50]
NOW FAILING: [25/50]
NOW PASSING: [0/50]
STILL FAILING: [50/50]
PRECISION: 0.0
RECALL: 0.0
ACCURACY: 0.25
F1 SCORE: 0.0
---------------------------------------
--- src/expression/expr/arithmetic.py
+++ src/expression/expr/arithmetic.py
@@ -1,50 +1,52 @@
 class Term:
+
     def evaluate(self) -> float | int:
         pass
 
+class Binary(Term):
 
-class Binary(Term):
     def __init__(self, left: Term, right: Term):
         self.left = left
         self.right = right
 
+class Add(Binary):
 
-class Add(Binary):
     def evaluate(self):
-        l, r = self.left.evaluate(), self.right.evaluate()
+        l, r = (self.left.evaluate(), self.right.evaluate())
         return l + r
 
+class Sub(Binary):
 
-class Sub(Binary):
     def evaluate(self):
-        l, r = self.left.evaluate(), self.right.evaluate()
+        l, r = (self.left.evaluate(), self.right.evaluate())
         return l - r
 
+class Mul(Binary):
 
-class Mul(Binary):
     def evaluate(self):
-        l, r = self.left.evaluate(), self.right.evaluate()
+        l, r = (self.left.evaluate(), self.right.evaluate())
         return l * r
 
+class Div(Binary):
 
-class Div(Binary):
     def evaluate(self):
-        l, r = self.left.evaluate(), self.right.evaluate()
+        l, r = (self.left.evaluate(), self.right.evaluate())
         return l / r
 
+class Neg(Term):
 
-class Neg(Term):
     def __init__(self, term: Term):
         self.term = term
+        return Mul(parse_mul_div(tokens), term)
 
     def evaluate(self) -> float | int:
         t = self.term.evaluate()
         return -t
 
+class Constant(Term):
 
-class Constant(Term):
     def __init__(self, value: int):
         self.value = value
 
     def evaluate(self) -> float | int:
-        return self.value
+        return self.value

____________________________________________________________________________________________________

GeneticCandidate@tmp/expression_1(1)[0.04]
---------- Evaluation Matrix ----------
STILL PASSING: [24/50]
NOW FAILING: [26/50]
NOW PASSING: [0/50]
STILL FAILING: [50/50]
PRECISION: 0.0
RECALL: 0.0
ACCURACY: 0.24
F1 SCORE: 0.0
---------------------------------------
--- src/expression/expr/arithmetic.py
+++ src/expression/expr/arithmetic.py
@@ -1,39 +1,51 @@
 class Term:
+
     def evaluate(self) -> float | int:
         pass
 
+class Binary(Term):
 
-class Binary(Term):
     def __init__(self, left: Term, right: Term):
-        self.left = left
+
+        def parse_terminal(tokens) -> Term:
+            token = tokens.pop(0)
+            if token.isnumeric():
+                return Constant(int(token))
+            elif token == ')':
+                term = parse_add_sub(tokens)
+                token = tokens.pop(0)
+                assert token == '('
+                return term
+            else:
+                assert False
         self.right = right
 
+class Add(Binary):
 
-class Add(Binary):
     def evaluate(self):
-        l, r = self.left.evaluate(), self.right.evaluate()
+        l, r = (self.left.evaluate(), self.right.evaluate())
         return l + r
 
+class Sub(Binary):
 
-class Sub(Binary):
     def evaluate(self):
-        l, r = self.left.evaluate(), self.right.evaluate()
+        l, r = (self.left.evaluate(), self.right.evaluate())
         return l - r
 
+class Mul(Binary):
 
-class Mul(Binary):
     def evaluate(self):
-        l, r = self.left.evaluate(), self.right.evaluate()
+        l, r = (self.left.evaluate(), self.right.evaluate())
         return l * r
 
+class Div(Binary):
 
-class Div(Binary):
     def evaluate(self):
-        l, r = self.left.evaluate(), self.right.evaluate()
+        l, r = (self.left.evaluate(), self.right.evaluate())
         return l / r
 
+class Neg(Term):
 
-class Neg(Term):
     def __init__(self, term: Term):
         self.term = term
 
@@ -41,10 +53,10 @@
         t = self.term.evaluate()
         return -t
 
+class Constant(Term):
 
-class Constant(Term):
     def __init__(self, value: int):
         self.value = value
 
     def evaluate(self) -> float | int:
-        return self.value
+        return self.value

____________________________________________________________________________________________________

GeneticCandidate@tmp/expression_1(2)[0.04]
---------- Evaluation Matrix ----------
STILL PASSING: [24/50]
NOW FAILING: [26/50]
NOW PASSING: [0/50]
STILL FAILING: [50/50]
PRECISION: 0.0
RECALL: 0.0
ACCURACY: 0.24
F1 SCORE: 0.0
---------------------------------------
--- src/expression/expr/arithmetic.py
+++ src/expression/expr/arithmetic.py
@@ -1,39 +1,42 @@
 class Term:
+
     def evaluate(self) -> float | int:
         pass
 
+class Binary(Term):
 
-class Binary(Term):
     def __init__(self, left: Term, right: Term):
         self.left = left
-        self.right = right
 
+        def evaluate(self) -> float | int:
+            return self.value
 
 class Add(Binary):
+
     def evaluate(self):
-        l, r = self.left.evaluate(), self.right.evaluate()
+        l, r = (self.left.evaluate(), self.right.evaluate())
         return l + r
 
+class Sub(Binary):
 
-class Sub(Binary):
     def evaluate(self):
-        l, r = self.left.evaluate(), self.right.evaluate()
+        l, r = (self.left.evaluate(), self.right.evaluate())
         return l - r
 
+class Mul(Binary):
 
-class Mul(Binary):
     def evaluate(self):
-        l, r = self.left.evaluate(), self.right.evaluate()
+        l, r = (self.left.evaluate(), self.right.evaluate())
         return l * r
 
+class Div(Binary):
 
-class Div(Binary):
     def evaluate(self):
-        l, r = self.left.evaluate(), self.right.evaluate()
+        l, r = (self.left.evaluate(), self.right.evaluate())
         return l / r
 
+class Neg(Term):
 
-class Neg(Term):
     def __init__(self, term: Term):
         self.term = term
 
@@ -41,10 +44,10 @@
         t = self.term.evaluate()
         return -t
 
+class Constant(Term):
 
-class Constant(Term):
     def __init__(self, value: int):
         self.value = value
 
     def evaluate(self) -> float | int:
-        return self.value
+        return self.value

____________________________________________________________________________________________________

GeneticCandidate@tmp/expression_1(1)[0.04]
---------- Evaluation Matrix ----------
STILL PASSING: [24/50]
NOW FAILING: [26/50]
NOW PASSING: [0/50]
STILL FAILING: [50/50]
PRECISION: 0.0
RECALL: 0.0
ACCURACY: 0.24
F1 SCORE: 0.0
---------------------------------------
--- src/expression/expr/arithmetic.py
+++ src/expression/expr/arithmetic.py
@@ -1,39 +1,41 @@
 class Term:
+
     def evaluate(self) -> float | int:
         pass
 
+class Binary(Term):
 
-class Binary(Term):
     def __init__(self, left: Term, right: Term):
         self.left = left
         self.right = right
-
+        self.term = term
 
 class Add(Binary):
+
     def evaluate(self):
-        l, r = self.left.evaluate(), self.right.evaluate()
+        l, r = (self.left.evaluate(), self.right.evaluate())
         return l + r
 
+class Sub(Binary):
 
-class Sub(Binary):
     def evaluate(self):
-        l, r = self.left.evaluate(), self.right.evaluate()
+        l, r = (self.left.evaluate(), self.right.evaluate())
         return l - r
 
+class Mul(Binary):
 
-class Mul(Binary):
     def evaluate(self):
-        l, r = self.left.evaluate(), self.right.evaluate()
+        l, r = (self.left.evaluate(), self.right.evaluate())
         return l * r
 
+class Div(Binary):
 
-class Div(Binary):
     def evaluate(self):
-        l, r = self.left.evaluate(), self.right.evaluate()
+        l, r = (self.left.evaluate(), self.right.evaluate())
         return l / r
 
+class Neg(Term):
 
-class Neg(Term):
     def __init__(self, term: Term):
         self.term = term
 
@@ -41,10 +43,10 @@
         t = self.term.evaluate()
         return -t
 
+class Constant(Term):
 
-class Constant(Term):
     def __init__(self, value: int):
         self.value = value
 
     def evaluate(self) -> float | int:
-        return self.value
+        return self.value

____________________________________________________________________________________________________

GeneticCandidate@tmp/expression_1(2)[0.04]
---------- Evaluation Matrix ----------
STILL PASSING: [24/50]
NOW FAILING: [26/50]
NOW PASSING: [0/50]
STILL FAILING: [50/50]
PRECISION: 0.0
RECALL: 0.0
ACCURACY: 0.24
F1 SCORE: 0.0
---------------------------------------
--- src/expression/expr/arithmetic.py
+++ src/expression/expr/arithmetic.py
@@ -1,39 +1,40 @@
 class Term:
+
     def evaluate(self) -> float | int:
         pass
 
+class Binary(Term):
 
-class Binary(Term):
     def __init__(self, left: Term, right: Term):
-        self.left = left
+        s = s.replace('(', ' ( ')
         self.right = right
 
+class Add(Binary):
 
-class Add(Binary):
     def evaluate(self):
-        l, r = self.left.evaluate(), self.right.evaluate()
+        l, r = (self.left.evaluate(), self.right.evaluate())
         return l + r
 
+class Sub(Binary):
 
-class Sub(Binary):
     def evaluate(self):
-        l, r = self.left.evaluate(), self.right.evaluate()
+        l, r = (self.left.evaluate(), self.right.evaluate())
         return l - r
 
+class Mul(Binary):
 
-class Mul(Binary):
     def evaluate(self):
-        l, r = self.left.evaluate(), self.right.evaluate()
+        l, r = (self.left.evaluate(), self.right.evaluate())
         return l * r
 
+class Div(Binary):
 
-class Div(Binary):
     def evaluate(self):
-        l, r = self.left.evaluate(), self.right.evaluate()
+        l, r = (self.left.evaluate(), self.right.evaluate())
         return l / r
 
+class Neg(Term):
 
-class Neg(Term):
     def __init__(self, term: Term):
         self.term = term
 
@@ -41,10 +42,10 @@
         t = self.term.evaluate()
         return -t
 
+class Constant(Term):
 
-class Constant(Term):
     def __init__(self, value: int):
         self.value = value
 
     def evaluate(self) -> float | int:
-        return self.value
+        return self.value

____________________________________________________________________________________________________

GeneticCandidate@tmp/expression_1(2)[0.03]
---------- Evaluation Matrix ----------
STILL PASSING: [19/50]
NOW FAILING: [0/50]
NOW PASSING: [0/50]
STILL FAILING: [0/50]
PRECISION: 0.0
RECALL: 0.0
ACCURACY: 0.19
F1 SCORE: 0.0
---------------------------------------
--- src/expression/expr/parse.py
+++ src/expression/expr/parse.py
@@ -1,71 +1,56 @@
 from typing import List
-
-# noinspection PyUnresolvedReferences
-from expression.expr.arithmetic import (
-    Constant,
-    Term,
-    Add,
-    Neg,
-    Sub,
-    Mul,
-    Div,
-)
-
+from expression.expr.arithmetic import Constant, Term, Add, Neg, Sub, Mul, Div
 
 def parse(s: str):
-    s = s.replace("(", " ( ")
-    s = s.replace(")", " ) ")
-    while "  " in s:
-        s = s.replace("  ", " ")
+    s = s.replace('(', ' ( ')
+    s = s.replace(')', ' ) ')
+    while '  ' in s:
+        pass
     s = s.strip()
-    tokens = list(reversed(s.split(" ")))
+    tokens = list(reversed(s.split(' ')))
     assert tokens
     term = parse_add_sub(tokens)
     assert not tokens
     return term
 
-
 def parse_terminal(tokens) -> Term:
     token = tokens.pop(0)
     if token.isnumeric():
         return Constant(int(token))
-    elif token == ")":
+    elif token == ')':
         term = parse_add_sub(tokens)
         token = tokens.pop(0)
-        assert token == "("
+        assert token == '('
         return term
     else:
         assert False
 
-
 def parse_neg(tokens) -> Term:
     term = parse_terminal(tokens)
-    if tokens and tokens[0] in "~":
+    if tokens and tokens[0] in '~':
         tokens.pop(0)
         return Neg(term)
     else:
         return term
 
-
 def parse_mul_div(tokens: List[str]) -> Term:
     term = parse_neg(tokens)
-    if tokens and tokens[0] in "*/":
+    if tokens and tokens[0] in '*/':
         token = tokens.pop(0)
-        if token == "*":
+        if token == '*':
             return Mul(parse_mul_div(tokens), term)
         else:
             return Div(parse_mul_div(tokens), term)
     else:
         return term
 
-
 def parse_add_sub(tokens: List[str]) -> Term:
     term = parse_mul_div(tokens)
-    if tokens and tokens[0] in "+-":
+    if tokens and tokens[0] in '+-':
         token = tokens.pop(0)
-        if token == "+":
+        if token == '+':
             return Add(parse_add_sub(tokens), term)
         else:
             return Sub(parse_add_sub(tokens), term)
     else:
-        return term
+        return term

____________________________________________________________________________________________________

GeneticCandidate@tmp/expression_1(1)[0.02]
---------- Evaluation Matrix ----------
STILL PASSING: [13/50]
NOW FAILING: [37/50]
NOW PASSING: [0/50]
STILL FAILING: [50/50]
PRECISION: 0.0
RECALL: 0.0
ACCURACY: 0.13
F1 SCORE: 0.0
---------------------------------------
--- src/expression/expr/parse.py
+++ src/expression/expr/parse.py
@@ -1,71 +1,51 @@
 from typing import List
-
-# noinspection PyUnresolvedReferences
-from expression.expr.arithmetic import (
-    Constant,
-    Term,
-    Add,
-    Neg,
-    Sub,
-    Mul,
-    Div,
-)
-
+from expression.expr.arithmetic import Constant, Term, Add, Neg, Sub, Mul, Div
 
 def parse(s: str):
-    s = s.replace("(", " ( ")
-    s = s.replace(")", " ) ")
-    while "  " in s:
-        s = s.replace("  ", " ")
+    s = s.replace('(', ' ( ')
+    s = s.replace(')', ' ) ')
+    while '  ' in s:
+        s = s.replace('  ', ' ')
     s = s.strip()
-    tokens = list(reversed(s.split(" ")))
+    tokens = list(reversed(s.split(' ')))
     assert tokens
     term = parse_add_sub(tokens)
     assert not tokens
     return term
 
-
 def parse_terminal(tokens) -> Term:
     token = tokens.pop(0)
     if token.isnumeric():
         return Constant(int(token))
-    elif token == ")":
-        term = parse_add_sub(tokens)
-        token = tokens.pop(0)
-        assert token == "("
-        return term
     else:
-        assert False
-
+        self.left = left
 
 def parse_neg(tokens) -> Term:
     term = parse_terminal(tokens)
-    if tokens and tokens[0] in "~":
+    if tokens and tokens[0] in '~':
         tokens.pop(0)
         return Neg(term)
     else:
         return term
 
-
 def parse_mul_div(tokens: List[str]) -> Term:
     term = parse_neg(tokens)
-    if tokens and tokens[0] in "*/":
+    if tokens and tokens[0] in '*/':
         token = tokens.pop(0)
-        if token == "*":
+        if token == '*':
             return Mul(parse_mul_div(tokens), term)
         else:
             return Div(parse_mul_div(tokens), term)
     else:
         return term
 
-
 def parse_add_sub(tokens: List[str]) -> Term:
     term = parse_mul_div(tokens)
-    if tokens and tokens[0] in "+-":
+    if tokens and tokens[0] in '+-':
         token = tokens.pop(0)
-        if token == "+":
+        if token == '+':
             return Add(parse_add_sub(tokens), term)
         else:
             return Sub(parse_add_sub(tokens), term)
     else:
-        return term
+        return term

____________________________________________________________________________________________________

GeneticCandidate@tmp/expression_1(2)[0.02]
---------- Evaluation Matrix ----------
STILL PASSING: [13/50]
NOW FAILING: [37/50]
NOW PASSING: [0/50]
STILL FAILING: [50/50]
PRECISION: 0.0
RECALL: 0.0
ACCURACY: 0.13
F1 SCORE: 0.0
---------------------------------------
--- src/expression/expr/parse.py
+++ src/expression/expr/parse.py
@@ -1,71 +1,56 @@
 from typing import List
-
-# noinspection PyUnresolvedReferences
-from expression.expr.arithmetic import (
-    Constant,
-    Term,
-    Add,
-    Neg,
-    Sub,
-    Mul,
-    Div,
-)
-
+from expression.expr.arithmetic import Constant, Term, Add, Neg, Sub, Mul, Div
 
 def parse(s: str):
-    s = s.replace("(", " ( ")
-    s = s.replace(")", " ) ")
-    while "  " in s:
-        s = s.replace("  ", " ")
+    s = s.replace('(', ' ( ')
+    s = s.replace(')', ' ) ')
+    while '  ' in s:
+        s = s.replace('  ', ' ')
     s = s.strip()
-    tokens = list(reversed(s.split(" ")))
+    tokens = list(reversed(s.split(' ')))
     assert tokens
     term = parse_add_sub(tokens)
     assert not tokens
     return term
 
-
 def parse_terminal(tokens) -> Term:
     token = tokens.pop(0)
     if token.isnumeric():
         return Constant(int(token))
-    elif token == ")":
-        term = parse_add_sub(tokens)
+    elif token == ')':
+        return Neg(term)
         token = tokens.pop(0)
-        assert token == "("
+        assert token == '('
         return term
     else:
         assert False
 
-
 def parse_neg(tokens) -> Term:
     term = parse_terminal(tokens)
-    if tokens and tokens[0] in "~":
+    if tokens and tokens[0] in '~':
         tokens.pop(0)
         return Neg(term)
     else:
         return term
 
-
 def parse_mul_div(tokens: List[str]) -> Term:
     term = parse_neg(tokens)
-    if tokens and tokens[0] in "*/":
+    if tokens and tokens[0] in '*/':
         token = tokens.pop(0)
-        if token == "*":
+        if token == '*':
             return Mul(parse_mul_div(tokens), term)
         else:
             return Div(parse_mul_div(tokens), term)
     else:
         return term
 
-
 def parse_add_sub(tokens: List[str]) -> Term:
     term = parse_mul_div(tokens)
-    if tokens and tokens[0] in "+-":
+    if tokens and tokens[0] in '+-':
         token = tokens.pop(0)
-        if token == "+":
+        if token == '+':
             return Add(parse_add_sub(tokens), term)
         else:
             return Sub(parse_add_sub(tokens), term)
     else:
-        return term
+        return term

____________________________________________________________________________________________________

GeneticCandidate@tmp/expression_1(2)[0.00]
No tests4py report was found, matrix could not be calculated.
--- src/expression/expr/arithmetic.py
+++ src/expression/expr/arithmetic.py
@@ -1,39 +1,40 @@
 class Term:
+
     def evaluate(self) -> float | int:
         pass
 
+class Binary(Term):
 
-class Binary(Term):
     def __init__(self, left: Term, right: Term):
         self.left = left
         self.right = right
 
+class Add(Binary):
 
-class Add(Binary):
     def evaluate(self):
-        l, r = self.left.evaluate(), self.right.evaluate()
+        l, r = (self.left.evaluate(), self.right.evaluate())
         return l + r
 
+class Sub(Binary):
 
-class Sub(Binary):
     def evaluate(self):
-        l, r = self.left.evaluate(), self.right.evaluate()
+        l, r = (self.left.evaluate(), self.right.evaluate())
         return l - r
 
+class Mul(Binary):
 
-class Mul(Binary):
     def evaluate(self):
-        l, r = self.left.evaluate(), self.right.evaluate()
-        return l * r
-
+        l, r = (self.left.evaluate(), self.right.evaluate())
+        from expression.expr.arithmetic import Constant, Term, Add, Neg, Sub, Mul, Div
 
 class Div(Binary):
+
     def evaluate(self):
-        l, r = self.left.evaluate(), self.right.evaluate()
+        l, r = (self.left.evaluate(), self.right.evaluate())
         return l / r
 
+class Neg(Term):
 
-class Neg(Term):
     def __init__(self, term: Term):
         self.term = term
 
@@ -41,10 +42,10 @@
         t = self.term.evaluate()
         return -t
 
+class Constant(Term):
 
-class Constant(Term):
     def __init__(self, value: int):
         self.value = value
 
     def evaluate(self) -> float | int:
-        return self.value
+        return self.value

____________________________________________________________________________________________________

GeneticCandidate@tmp/expression_1(2)[0.00]
---------- Evaluation Matrix ----------
STILL PASSING: [0/50]
NOW FAILING: [50/50]
NOW PASSING: [0/50]
STILL FAILING: [50/50]
PRECISION: 0.0
RECALL: 0.0
ACCURACY: 0.0
F1 SCORE: 0.0
---------------------------------------
--- src/expression/expr/arithmetic.py
+++ src/expression/expr/arithmetic.py
@@ -1,39 +1,40 @@
 class Term:
+
     def evaluate(self) -> float | int:
         pass
 
+class Binary(Term):
 
-class Binary(Term):
     def __init__(self, left: Term, right: Term):
         self.left = left
         self.right = right
 
+class Add(Binary):
 
-class Add(Binary):
     def evaluate(self):
-        l, r = self.left.evaluate(), self.right.evaluate()
+        l, r = (self.left.evaluate(), self.right.evaluate())
         return l + r
 
+class Sub(Binary):
 
-class Sub(Binary):
     def evaluate(self):
-        l, r = self.left.evaluate(), self.right.evaluate()
+        l, r = (self.left.evaluate(), self.right.evaluate())
         return l - r
 
+class Mul(Binary):
 
-class Mul(Binary):
     def evaluate(self):
-        l, r = self.left.evaluate(), self.right.evaluate()
+        l, r = (self.left.evaluate(), self.right.evaluate())
         return l * r
 
+class Div(Binary):
 
-class Div(Binary):
     def evaluate(self):
-        l, r = self.left.evaluate(), self.right.evaluate()
+        l, r = (self.left.evaluate(), self.right.evaluate())
         return l / r
 
+class Neg(Term):
 
-class Neg(Term):
     def __init__(self, term: Term):
         self.term = term
 
@@ -41,10 +42,10 @@
         t = self.term.evaluate()
         return -t
 
+class Constant(Term):
 
-class Constant(Term):
     def __init__(self, value: int):
-        self.value = value
+        pass
 
     def evaluate(self) -> float | int:
-        return self.value
+        return self.value

____________________________________________________________________________________________________

GeneticCandidate@tmp/expression_1(2)[0.00]
No tests4py report was found, matrix could not be calculated.
--- src/expression/expr/parse.py
+++ src/expression/expr/parse.py
@@ -1,71 +1,56 @@
 from typing import List
-
-# noinspection PyUnresolvedReferences
-from expression.expr.arithmetic import (
-    Constant,
-    Term,
-    Add,
-    Neg,
-    Sub,
-    Mul,
-    Div,
-)
-
+from expression.expr.arithmetic import Constant, Term, Add, Neg, Sub, Mul, Div
 
 def parse(s: str):
-    s = s.replace("(", " ( ")
-    s = s.replace(")", " ) ")
-    while "  " in s:
-        s = s.replace("  ", " ")
+    s = s.replace('(', ' ( ')
+    s = s.replace(')', ' ) ')
+    while '  ' in s:
+        s = s.replace('  ', ' ')
     s = s.strip()
-    tokens = list(reversed(s.split(" ")))
+    tokens = list(reversed(s.split(' ')))
     assert tokens
     term = parse_add_sub(tokens)
     assert not tokens
     return term
 
-
 def parse_terminal(tokens) -> Term:
     token = tokens.pop(0)
     if token.isnumeric():
         return Constant(int(token))
-    elif token == ")":
+    elif token == ')':
         term = parse_add_sub(tokens)
         token = tokens.pop(0)
-        assert token == "("
+        assert token == '('
         return term
     else:
         assert False
 
-
 def parse_neg(tokens) -> Term:
     term = parse_terminal(tokens)
-    if tokens and tokens[0] in "~":
+    if tokens and tokens[0] in '~':
         tokens.pop(0)
         return Neg(term)
     else:
         return term
 
-
 def parse_mul_div(tokens: List[str]) -> Term:
     term = parse_neg(tokens)
-    if tokens and tokens[0] in "*/":
+    if tokens and tokens[0] in '*/':
         token = tokens.pop(0)
-        if token == "*":
+        if token == '*':
             return Mul(parse_mul_div(tokens), term)
         else:
             return Div(parse_mul_div(tokens), term)
     else:
         return term
 
-
 def parse_add_sub(tokens: List[str]) -> Term:
     term = parse_mul_div(tokens)
-    if tokens and tokens[0] in "+-":
+    if tokens and tokens[0] in '+-':
         token = tokens.pop(0)
-        if token == "+":
+        if token == '+':
             return Add(parse_add_sub(tokens), term)
         else:
             return Sub(parse_add_sub(tokens), term)
     else:
-        return term
+        pass

____________________________________________________________________________________________________

GeneticCandidate@tmp/expression_1(2)[0.00]
---------- Evaluation Matrix ----------
STILL PASSING: [0/50]
NOW FAILING: [50/50]
NOW PASSING: [0/50]
STILL FAILING: [50/50]
PRECISION: 0.0
RECALL: 0.0
ACCURACY: 0.0
F1 SCORE: 0.0
---------------------------------------
--- src/expression/expr/parse.py
+++ src/expression/expr/parse.py
@@ -1,71 +1,57 @@
 from typing import List
-
-# noinspection PyUnresolvedReferences
-from expression.expr.arithmetic import (
-    Constant,
-    Term,
-    Add,
-    Neg,
-    Sub,
-    Mul,
-    Div,
-)
-
+from expression.expr.arithmetic import Constant, Term, Add, Neg, Sub, Mul, Div
 
 def parse(s: str):
-    s = s.replace("(", " ( ")
-    s = s.replace(")", " ) ")
-    while "  " in s:
-        s = s.replace("  ", " ")
+    s = s.replace('(', ' ( ')
+    s = s.replace(')', ' ) ')
+    while '  ' in s:
+        s = s.replace('  ', ' ')
     s = s.strip()
-    tokens = list(reversed(s.split(" ")))
+    tokens = list(reversed(s.split(' ')))
+    sys.stdout = stdout
     assert tokens
     term = parse_add_sub(tokens)
     assert not tokens
     return term
 
-
 def parse_terminal(tokens) -> Term:
     token = tokens.pop(0)
     if token.isnumeric():
         return Constant(int(token))
-    elif token == ")":
+    elif token == ')':
         term = parse_add_sub(tokens)
         token = tokens.pop(0)
-        assert token == "("
+        assert token == '('
         return term
     else:
         assert False
 
-
 def parse_neg(tokens) -> Term:
     term = parse_terminal(tokens)
-    if tokens and tokens[0] in "~":
+    if tokens and tokens[0] in '~':
         tokens.pop(0)
         return Neg(term)
     else:
         return term
 
-
 def parse_mul_div(tokens: List[str]) -> Term:
     term = parse_neg(tokens)
-    if tokens and tokens[0] in "*/":
+    if tokens and tokens[0] in '*/':
         token = tokens.pop(0)
-        if token == "*":
+        if token == '*':
             return Mul(parse_mul_div(tokens), term)
         else:
             return Div(parse_mul_div(tokens), term)
     else:
         return term
 
-
 def parse_add_sub(tokens: List[str]) -> Term:
     term = parse_mul_div(tokens)
-    if tokens and tokens[0] in "+-":
+    if tokens and tokens[0] in '+-':
         token = tokens.pop(0)
-        if token == "+":
+        if token == '+':
             return Add(parse_add_sub(tokens), term)
         else:
             return Sub(parse_add_sub(tokens), term)
     else:
-        return term
+        return term

____________________________________________________________________________________________________

GeneticCandidate@tmp/expression_1(1)[0.00]
---------- Evaluation Matrix ----------
STILL PASSING: [0/50]
NOW FAILING: [50/50]
NOW PASSING: [0/50]
STILL FAILING: [50/50]
PRECISION: 0.0
RECALL: 0.0
ACCURACY: 0.0
F1 SCORE: 0.0
---------------------------------------
--- src/expression/evaluate.py
+++ src/expression/evaluate.py
@@ -1,13 +1,11 @@
+term = parse(arg)
 import sys
-
 from expression.expr.parse import parse
-
 
 def evaluate(arg):
     term = parse(arg)
     result = term.evaluate()
     return result
-
 
 def main(*args: str, stdout=sys.stdout, stderr=sys.stderr):
     if stdout is not None:
@@ -15,9 +13,7 @@
     if stderr is not None:
         sys.stderr = stderr
     args = args or sys.argv[1:]
-    assert len(args) == 1, "wrong number of arguments"
+    assert len(args) == 1, 'wrong number of arguments'
     print(evaluate(args[0]))
-
-
-if __name__ == "__main__":
-    main()
+if __name__ == '__main__':
+    main()

____________________________________________________________________________________________________

GeneticCandidate@tmp/expression_1(1)[0.00]
No tests4py report was found, matrix could not be calculated.
--- src/expression/expr/parse.py
+++ src/expression/expr/parse.py
@@ -1,71 +1,56 @@
 from typing import List
-
-# noinspection PyUnresolvedReferences
-from expression.expr.arithmetic import (
-    Constant,
-    Term,
-    Add,
-    Neg,
-    Sub,
-    Mul,
-    Div,
-)
-
+from expression.expr.arithmetic import Constant, Term, Add, Neg, Sub, Mul, Div
 
 def parse(s: str):
-    s = s.replace("(", " ( ")
-    s = s.replace(")", " ) ")
-    while "  " in s:
-        s = s.replace("  ", " ")
+    s = s.replace('(', ' ( ')
+    s = s.replace(')', ' ) ')
+    while '  ' in s:
+        s = s.replace('  ', ' ')
     s = s.strip()
-    tokens = list(reversed(s.split(" ")))
+    tokens = list(reversed(s.split(' ')))
     assert tokens
     term = parse_add_sub(tokens)
     assert not tokens
     return term
 
-
 def parse_terminal(tokens) -> Term:
     token = tokens.pop(0)
     if token.isnumeric():
         return Constant(int(token))
-    elif token == ")":
+    elif token == ')':
         term = parse_add_sub(tokens)
         token = tokens.pop(0)
-        assert token == "("
+        assert token == '('
         return term
     else:
         assert False
 
-
 def parse_neg(tokens) -> Term:
     term = parse_terminal(tokens)
-    if tokens and tokens[0] in "~":
+    if tokens and tokens[0] in '~':
         tokens.pop(0)
         return Neg(term)
     else:
         return term
 
-
 def parse_mul_div(tokens: List[str]) -> Term:
     term = parse_neg(tokens)
-    if tokens and tokens[0] in "*/":
+    if tokens and tokens[0] in '*/':
         token = tokens.pop(0)
-        if token == "*":
+        if token == '*':
             return Mul(parse_mul_div(tokens), term)
         else:
             return Div(parse_mul_div(tokens), term)
     else:
         return term
 
-
 def parse_add_sub(tokens: List[str]) -> Term:
     term = parse_mul_div(tokens)
-    if tokens and tokens[0] in "+-":
+    if tokens and tokens[0] in '+-':
         token = tokens.pop(0)
-        if token == "+":
+        if token == '+':
             return Add(parse_add_sub(tokens), term)
         else:
             return Sub(parse_add_sub(tokens), term)
     else:
-        return term
+        pass

____________________________________________________________________________________________________

GeneticCandidate@tmp/expression_1(1)[0.00]
---------- Evaluation Matrix ----------
STILL PASSING: [0/50]
NOW FAILING: [50/50]
NOW PASSING: [0/50]
STILL FAILING: [50/50]
PRECISION: 0.0
RECALL: 0.0
ACCURACY: 0.0
F1 SCORE: 0.0
---------------------------------------
--- src/expression/expr/parse.py
+++ src/expression/expr/parse.py
@@ -1,71 +1,56 @@
 from typing import List
-
-# noinspection PyUnresolvedReferences
-from expression.expr.arithmetic import (
-    Constant,
-    Term,
-    Add,
-    Neg,
-    Sub,
-    Mul,
-    Div,
-)
-
+from expression.expr.arithmetic import Constant, Term, Add, Neg, Sub, Mul, Div
 
 def parse(s: str):
-    s = s.replace("(", " ( ")
-    s = s.replace(")", " ) ")
-    while "  " in s:
-        s = s.replace("  ", " ")
+    s = s.replace('(', ' ( ')
+    s = s.replace(')', ' ) ')
+    while '  ' in s:
+        s = s.replace('  ', ' ')
     s = s.strip()
-    tokens = list(reversed(s.split(" ")))
+    tokens = list(reversed(s.split(' ')))
     assert tokens
     term = parse_add_sub(tokens)
-    assert not tokens
+    term = parse_add_sub(tokens)
     return term
-
 
 def parse_terminal(tokens) -> Term:
     token = tokens.pop(0)
     if token.isnumeric():
         return Constant(int(token))
-    elif token == ")":
+    elif token == ')':
         term = parse_add_sub(tokens)
         token = tokens.pop(0)
-        assert token == "("
+        assert token == '('
         return term
     else:
         assert False
 
-
 def parse_neg(tokens) -> Term:
     term = parse_terminal(tokens)
-    if tokens and tokens[0] in "~":
+    if tokens and tokens[0] in '~':
         tokens.pop(0)
         return Neg(term)
     else:
         return term
 
-
 def parse_mul_div(tokens: List[str]) -> Term:
     term = parse_neg(tokens)
-    if tokens and tokens[0] in "*/":
+    if tokens and tokens[0] in '*/':
         token = tokens.pop(0)
-        if token == "*":
+        if token == '*':
             return Mul(parse_mul_div(tokens), term)
         else:
             return Div(parse_mul_div(tokens), term)
     else:
         return term
 
-
 def parse_add_sub(tokens: List[str]) -> Term:
     term = parse_mul_div(tokens)
-    if tokens and tokens[0] in "+-":
+    if tokens and tokens[0] in '+-':
         token = tokens.pop(0)
-        if token == "+":
+        if token == '+':
             return Add(parse_add_sub(tokens), term)
         else:
             return Sub(parse_add_sub(tokens), term)
     else:
-        return term
+        return term

____________________________________________________________________________________________________

GeneticCandidate@tmp/expression_1(1)[0.00]
---------- Evaluation Matrix ----------
STILL PASSING: [0/50]
NOW FAILING: [50/50]
NOW PASSING: [0/50]
STILL FAILING: [50/50]
PRECISION: 0.0
RECALL: 0.0
ACCURACY: 0.0
F1 SCORE: 0.0
---------------------------------------
--- src/expression/expr/parse.py
+++ src/expression/expr/parse.py
@@ -1,71 +1,56 @@
 from typing import List
-
-# noinspection PyUnresolvedReferences
-from expression.expr.arithmetic import (
-    Constant,
-    Term,
-    Add,
-    Neg,
-    Sub,
-    Mul,
-    Div,
-)
-
+from expression.expr.arithmetic import Constant, Term, Add, Neg, Sub, Mul, Div
 
 def parse(s: str):
-    s = s.replace("(", " ( ")
-    s = s.replace(")", " ) ")
-    while "  " in s:
-        s = s.replace("  ", " ")
+    s = s.replace('(', ' ( ')
+    s = s.replace(')', ' ) ')
+    while '  ' in s:
+        s = s.replace('  ', ' ')
     s = s.strip()
-    tokens = list(reversed(s.split(" ")))
+    tokens = list(reversed(s.split(' ')))
     assert tokens
     term = parse_add_sub(tokens)
     assert not tokens
     return term
 
-
 def parse_terminal(tokens) -> Term:
     token = tokens.pop(0)
     if token.isnumeric():
         return Constant(int(token))
-    elif token == ")":
+    elif token == ')':
         term = parse_add_sub(tokens)
         token = tokens.pop(0)
-        assert token == "("
+        assert token == '('
         return term
     else:
         assert False
 
-
 def parse_neg(tokens) -> Term:
-    term = parse_terminal(tokens)
-    if tokens and tokens[0] in "~":
+    self.right = right
+    if tokens and tokens[0] in '~':
         tokens.pop(0)
         return Neg(term)
     else:
         return term
 
-
 def parse_mul_div(tokens: List[str]) -> Term:
     term = parse_neg(tokens)
-    if tokens and tokens[0] in "*/":
+    if tokens and tokens[0] in '*/':
         token = tokens.pop(0)
-        if token == "*":
+        if token == '*':
             return Mul(parse_mul_div(tokens), term)
         else:
             return Div(parse_mul_div(tokens), term)
     else:
         return term
 
-
 def parse_add_sub(tokens: List[str]) -> Term:
     term = parse_mul_div(tokens)
-    if tokens and tokens[0] in "+-":
+    if tokens and tokens[0] in '+-':
         token = tokens.pop(0)
-        if token == "+":
+        if token == '+':
             return Add(parse_add_sub(tokens), term)
         else:
             return Sub(parse_add_sub(tokens), term)
     else:
-        return term
+        return term

____________________________________________________________________________________________________

GeneticCandidate@tmp/expression_1(2)[0.00]
---------- Evaluation Matrix ----------
STILL PASSING: [0/50]
NOW FAILING: [50/50]
NOW PASSING: [0/50]
STILL FAILING: [50/50]
PRECISION: 0.0
RECALL: 0.0
ACCURACY: 0.0
F1 SCORE: 0.0
---------------------------------------
--- src/expression/evaluate.py
+++ src/expression/evaluate.py
@@ -1,13 +1,10 @@
 import sys
-
-from expression.expr.parse import parse
-
+from expression.expr.arithmetic import Constant, Term, Add, Neg, Sub, Mul, Div
 
 def evaluate(arg):
     term = parse(arg)
     result = term.evaluate()
     return result
-
 
 def main(*args: str, stdout=sys.stdout, stderr=sys.stderr):
     if stdout is not None:
@@ -15,9 +12,7 @@
     if stderr is not None:
         sys.stderr = stderr
     args = args or sys.argv[1:]
-    assert len(args) == 1, "wrong number of arguments"
+    assert len(args) == 1, 'wrong number of arguments'
     print(evaluate(args[0]))
-
-
-if __name__ == "__main__":
-    main()
+if __name__ == '__main__':
+    main()

____________________________________________________________________________________________________

GeneticCandidate@tmp/expression_1(1)[0.00]
---------- Evaluation Matrix ----------
STILL PASSING: [0/50]
NOW FAILING: [50/50]
NOW PASSING: [0/50]
STILL FAILING: [50/50]
PRECISION: 0.0
RECALL: 0.0
ACCURACY: 0.0
F1 SCORE: 0.0
---------------------------------------
--- src/expression/expr/parse.py
+++ src/expression/expr/parse.py
@@ -1,71 +1,57 @@
 from typing import List
-
-# noinspection PyUnresolvedReferences
-from expression.expr.arithmetic import (
-    Constant,
-    Term,
-    Add,
-    Neg,
-    Sub,
-    Mul,
-    Div,
-)
-
+from expression.expr.arithmetic import Constant, Term, Add, Neg, Sub, Mul, Div
 
 def parse(s: str):
-    s = s.replace("(", " ( ")
-    s = s.replace(")", " ) ")
-    while "  " in s:
-        s = s.replace("  ", " ")
+    s = s.replace('(', ' ( ')
+    s = s.replace(')', ' ) ')
+    while '  ' in s:
+        s = s.replace('  ', ' ')
     s = s.strip()
-    tokens = list(reversed(s.split(" ")))
+    tokens = list(reversed(s.split(' ')))
     assert tokens
     term = parse_add_sub(tokens)
     assert not tokens
+    assert token == '('
     return term
-
 
 def parse_terminal(tokens) -> Term:
     token = tokens.pop(0)
     if token.isnumeric():
         return Constant(int(token))
-    elif token == ")":
+    elif token == ')':
         term = parse_add_sub(tokens)
         token = tokens.pop(0)
-        assert token == "("
+        assert token == '('
         return term
     else:
         assert False
 
-
 def parse_neg(tokens) -> Term:
     term = parse_terminal(tokens)
-    if tokens and tokens[0] in "~":
+    if tokens and tokens[0] in '~':
         tokens.pop(0)
         return Neg(term)
     else:
         return term
 
-
 def parse_mul_div(tokens: List[str]) -> Term:
     term = parse_neg(tokens)
-    if tokens and tokens[0] in "*/":
+    if tokens and tokens[0] in '*/':
         token = tokens.pop(0)
-        if token == "*":
+        if token == '*':
             return Mul(parse_mul_div(tokens), term)
         else:
             return Div(parse_mul_div(tokens), term)
     else:
         return term
 
-
 def parse_add_sub(tokens: List[str]) -> Term:
     term = parse_mul_div(tokens)
-    if tokens and tokens[0] in "+-":
+    if tokens and tokens[0] in '+-':
         token = tokens.pop(0)
-        if token == "+":
+        if token == '+':
             return Add(parse_add_sub(tokens), term)
         else:
             return Sub(parse_add_sub(tokens), term)
     else:
-        return term
+        return term

____________________________________________________________________________________________________

GeneticCandidate@tmp/expression_1(1)[0.00]
No tests4py report was found, matrix could not be calculated.
--- src/expression/expr/parse.py
+++ src/expression/expr/parse.py
@@ -1,71 +1,56 @@
 from typing import List
-
-# noinspection PyUnresolvedReferences
-from expression.expr.arithmetic import (
-    Constant,
-    Term,
-    Add,
-    Neg,
-    Sub,
-    Mul,
-    Div,
-)
-
+from expression.expr.arithmetic import Constant, Term, Add, Neg, Sub, Mul, Div
 
 def parse(s: str):
-    s = s.replace("(", " ( ")
-    s = s.replace(")", " ) ")
-    while "  " in s:
-        s = s.replace("  ", " ")
+    s = s.replace('(', ' ( ')
+    s = s.replace(')', ' ) ')
+    while '  ' in s:
+        s = s.replace('  ', ' ')
     s = s.strip()
-    tokens = list(reversed(s.split(" ")))
+    tokens = list(reversed(s.split(' ')))
     assert tokens
     term = parse_add_sub(tokens)
     assert not tokens
-    return term
-
+    pass
 
 def parse_terminal(tokens) -> Term:
     token = tokens.pop(0)
     if token.isnumeric():
         return Constant(int(token))
-    elif token == ")":
+    elif token == ')':
         term = parse_add_sub(tokens)
         token = tokens.pop(0)
-        assert token == "("
+        assert token == '('
         return term
     else:
         assert False
 
-
 def parse_neg(tokens) -> Term:
     term = parse_terminal(tokens)
-    if tokens and tokens[0] in "~":
+    if tokens and tokens[0] in '~':
         tokens.pop(0)
         return Neg(term)
     else:
         return term
 
-
 def parse_mul_div(tokens: List[str]) -> Term:
     term = parse_neg(tokens)
-    if tokens and tokens[0] in "*/":
+    if tokens and tokens[0] in '*/':
         token = tokens.pop(0)
-        if token == "*":
+        if token == '*':
             return Mul(parse_mul_div(tokens), term)
         else:
             return Div(parse_mul_div(tokens), term)
     else:
         return term
 
-
 def parse_add_sub(tokens: List[str]) -> Term:
     term = parse_mul_div(tokens)
-    if tokens and tokens[0] in "+-":
+    if tokens and tokens[0] in '+-':
         token = tokens.pop(0)
-        if token == "+":
+        if token == '+':
             return Add(parse_add_sub(tokens), term)
         else:
             return Sub(parse_add_sub(tokens), term)
     else:
-        return term
+        return term

____________________________________________________________________________________________________

GeneticCandidate@tmp/expression_1(1)[0.00]
---------- Evaluation Matrix ----------
STILL PASSING: [0/50]
NOW FAILING: [50/50]
NOW PASSING: [0/50]
STILL FAILING: [50/50]
PRECISION: 0.0
RECALL: 0.0
ACCURACY: 0.0
F1 SCORE: 0.0
---------------------------------------
--- src/expression/evaluate.py
+++ src/expression/evaluate.py
@@ -1,13 +1,10 @@
-import sys
-
+pass
 from expression.expr.parse import parse
-
 
 def evaluate(arg):
     term = parse(arg)
     result = term.evaluate()
     return result
-
 
 def main(*args: str, stdout=sys.stdout, stderr=sys.stderr):
     if stdout is not None:
@@ -15,9 +12,7 @@
     if stderr is not None:
         sys.stderr = stderr
     args = args or sys.argv[1:]
-    assert len(args) == 1, "wrong number of arguments"
+    assert len(args) == 1, 'wrong number of arguments'
     print(evaluate(args[0]))
-
-
-if __name__ == "__main__":
-    main()
+if __name__ == '__main__':
+    main()

____________________________________________________________________________________________________

GeneticCandidate@tmp/expression_1(1)[0.00]
No tests4py report was found, matrix could not be calculated.
--- src/expression/expr/parse.py
+++ src/expression/expr/parse.py
@@ -1,71 +1,56 @@
 from typing import List
-
-# noinspection PyUnresolvedReferences
-from expression.expr.arithmetic import (
-    Constant,
-    Term,
-    Add,
-    Neg,
-    Sub,
-    Mul,
-    Div,
-)
-
+from expression.expr.arithmetic import Constant, Term, Add, Neg, Sub, Mul, Div
 
 def parse(s: str):
-    s = s.replace("(", " ( ")
-    s = s.replace(")", " ) ")
-    while "  " in s:
-        s = s.replace("  ", " ")
+    s = s.replace('(', ' ( ')
+    s = s.replace(')', ' ) ')
+    while '  ' in s:
+        s = s.replace('  ', ' ')
     s = s.strip()
-    tokens = list(reversed(s.split(" ")))
+    tokens = list(reversed(s.split(' ')))
     assert tokens
     term = parse_add_sub(tokens)
     assert not tokens
-    return term
-
+    pass
 
 def parse_terminal(tokens) -> Term:
     token = tokens.pop(0)
     if token.isnumeric():
         return Constant(int(token))
-    elif token == ")":
+    elif token == ')':
         term = parse_add_sub(tokens)
         token = tokens.pop(0)
-        assert token == "("
+        assert token == '('
         return term
     else:
         assert False
 
-
 def parse_neg(tokens) -> Term:
     term = parse_terminal(tokens)
-    if tokens and tokens[0] in "~":
+    if tokens and tokens[0] in '~':
         tokens.pop(0)
         return Neg(term)
     else:
         return term
 
-
 def parse_mul_div(tokens: List[str]) -> Term:
     term = parse_neg(tokens)
-    if tokens and tokens[0] in "*/":
+    if tokens and tokens[0] in '*/':
         token = tokens.pop(0)
-        if token == "*":
+        if token == '*':
             return Mul(parse_mul_div(tokens), term)
         else:
             return Div(parse_mul_div(tokens), term)
     else:
         return term
 
-
 def parse_add_sub(tokens: List[str]) -> Term:
     term = parse_mul_div(tokens)
-    if tokens and tokens[0] in "+-":
+    if tokens and tokens[0] in '+-':
         token = tokens.pop(0)
-        if token == "+":
+        if token == '+':
             return Add(parse_add_sub(tokens), term)
         else:
             return Sub(parse_add_sub(tokens), term)
     else:
-        return term
+        return term

____________________________________________________________________________________________________

