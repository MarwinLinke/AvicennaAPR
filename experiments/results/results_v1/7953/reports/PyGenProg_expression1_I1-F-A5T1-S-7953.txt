APPROACH: PyGenProg
SUBJECT: expression_1
Used 5 failing and 5 passing test cases from Avicenna in the fault localization
Used 1 failing and 10 passing test cases from Tests4py in the validation
In total 10 for fault localization and 11 for validation.
The gathering of test cases took 8.3231 seconds.
The repair ran for 667.9192 seconds.
The evaluation took 337.5336 seconds.
Was a valid patch found: False
BEST FITNESS: 0.09090909090909091
BEST F1 SCORE: 0.0
Found a total of 36 patches.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

PATCHES (SORTED):
GeneticCandidate@tmp/expression_1(2)[0.09]
---------- Evaluation Matrix ----------
STILL PASSING: [50/50]
NOW FAILING: [0/50]
NOW PASSING: [0/50]
STILL FAILING: [50/50]
PRECISION: 0.0
RECALL: 0.0
ACCURACY: 0.5
F1 SCORE: 0.0
---------------------------------------
--- src/expression/expr/arithmetic.py
+++ src/expression/expr/arithmetic.py
@@ -1,39 +1,40 @@
 class Term:
+
     def evaluate(self) -> float | int:
         pass
 
+class Binary(Term):
 
-class Binary(Term):
     def __init__(self, left: Term, right: Term):
         self.left = left
         self.right = right
 
+class Add(Binary):
 
-class Add(Binary):
     def evaluate(self):
-        l, r = self.left.evaluate(), self.right.evaluate()
+        l, r = (self.left.evaluate(), self.right.evaluate())
         return l + r
 
+class Sub(Binary):
 
-class Sub(Binary):
     def evaluate(self):
-        l, r = self.left.evaluate(), self.right.evaluate()
+        l, r = (self.left.evaluate(), self.right.evaluate())
         return l - r
 
+class Mul(Binary):
 
-class Mul(Binary):
     def evaluate(self):
-        l, r = self.left.evaluate(), self.right.evaluate()
+        l, r = (self.left.evaluate(), self.right.evaluate())
         return l * r
 
+class Div(Binary):
 
-class Div(Binary):
     def evaluate(self):
-        l, r = self.left.evaluate(), self.right.evaluate()
+        l, r = (self.left.evaluate(), self.right.evaluate())
         return l / r
 
+class Neg(Term):
 
-class Neg(Term):
     def __init__(self, term: Term):
         self.term = term
 
@@ -41,10 +42,16 @@
         t = self.term.evaluate()
         return -t
 
+class Constant(Term):
 
-class Constant(Term):
     def __init__(self, value: int):
         self.value = value
 
     def evaluate(self) -> float | int:
-        return self.value
+
+        class Binary(Term):
+
+            def __init__(self, left: Term, right: Term):
+                self.left = left
+                self.right = right
+        return self.value

____________________________________________________________________________________________________

GeneticCandidate@tmp/expression_1(2)[0.09]
---------- Evaluation Matrix ----------
STILL PASSING: [50/50]
NOW FAILING: [0/50]
NOW PASSING: [0/50]
STILL FAILING: [50/50]
PRECISION: 0.0
RECALL: 0.0
ACCURACY: 0.5
F1 SCORE: 0.0
---------------------------------------
--- src/expression/expr/parse.py
+++ src/expression/expr/parse.py
@@ -1,71 +1,56 @@
 from typing import List
-
-# noinspection PyUnresolvedReferences
-from expression.expr.arithmetic import (
-    Constant,
-    Term,
-    Add,
-    Neg,
-    Sub,
-    Mul,
-    Div,
-)
-
+from expression.expr.arithmetic import Constant, Term, Add, Neg, Sub, Mul, Div
 
 def parse(s: str):
-    s = s.replace("(", " ( ")
-    s = s.replace(")", " ) ")
-    while "  " in s:
-        s = s.replace("  ", " ")
+    s = s.replace('(', ' ( ')
+    s = s.replace(')', ' ) ')
+    while '  ' in s:
+        s = s.replace('  ', ' ')
     s = s.strip()
-    tokens = list(reversed(s.split(" ")))
+    tokens = list(reversed(s.split(' ')))
     assert tokens
     term = parse_add_sub(tokens)
     assert not tokens
     return term
 
-
 def parse_terminal(tokens) -> Term:
     token = tokens.pop(0)
     if token.isnumeric():
         return Constant(int(token))
-    elif token == ")":
+    elif token == ')':
         term = parse_add_sub(tokens)
         token = tokens.pop(0)
-        assert token == "("
+        pass
         return term
     else:
         assert False
 
-
 def parse_neg(tokens) -> Term:
     term = parse_terminal(tokens)
-    if tokens and tokens[0] in "~":
+    if tokens and tokens[0] in '~':
         tokens.pop(0)
         return Neg(term)
     else:
         return term
 
-
 def parse_mul_div(tokens: List[str]) -> Term:
     term = parse_neg(tokens)
-    if tokens and tokens[0] in "*/":
+    if tokens and tokens[0] in '*/':
         token = tokens.pop(0)
-        if token == "*":
+        if token == '*':
             return Mul(parse_mul_div(tokens), term)
         else:
             return Div(parse_mul_div(tokens), term)
     else:
         return term
 
-
 def parse_add_sub(tokens: List[str]) -> Term:
     term = parse_mul_div(tokens)
-    if tokens and tokens[0] in "+-":
+    if tokens and tokens[0] in '+-':
         token = tokens.pop(0)
-        if token == "+":
+        if token == '+':
             return Add(parse_add_sub(tokens), term)
         else:
             return Sub(parse_add_sub(tokens), term)
     else:
-        return term
+        return term

____________________________________________________________________________________________________

GeneticCandidate@tmp/expression_1(2)[0.09]
---------- Evaluation Matrix ----------
STILL PASSING: [50/50]
NOW FAILING: [0/50]
NOW PASSING: [0/50]
STILL FAILING: [50/50]
PRECISION: 0.0
RECALL: 0.0
ACCURACY: 0.5
F1 SCORE: 0.0
---------------------------------------
--- src/expression/expr/arithmetic.py
+++ src/expression/expr/arithmetic.py
@@ -1,39 +1,40 @@
 class Term:
+
     def evaluate(self) -> float | int:
         pass
 
+class Binary(Term):
 
-class Binary(Term):
     def __init__(self, left: Term, right: Term):
         self.left = left
         self.right = right
 
+class Add(Binary):
 
-class Add(Binary):
     def evaluate(self):
-        l, r = self.left.evaluate(), self.right.evaluate()
+        l, r = (self.left.evaluate(), self.right.evaluate())
         return l + r
 
+class Sub(Binary):
 
-class Sub(Binary):
     def evaluate(self):
-        l, r = self.left.evaluate(), self.right.evaluate()
+        l, r = (self.left.evaluate(), self.right.evaluate())
         return l - r
 
+class Mul(Binary):
 
-class Mul(Binary):
     def evaluate(self):
-        l, r = self.left.evaluate(), self.right.evaluate()
+        l, r = (self.left.evaluate(), self.right.evaluate())
         return l * r
 
+class Div(Binary):
 
-class Div(Binary):
     def evaluate(self):
-        l, r = self.left.evaluate(), self.right.evaluate()
+        l, r = (self.left.evaluate(), self.right.evaluate())
         return l / r
 
+class Neg(Term):
 
-class Neg(Term):
     def __init__(self, term: Term):
         self.term = term
 
@@ -41,10 +42,10 @@
         t = self.term.evaluate()
         return -t
 
+class Constant(Term):
 
-class Constant(Term):
     def __init__(self, value: int):
         self.value = value
 
     def evaluate(self) -> float | int:
-        return self.value
+        return self.value

____________________________________________________________________________________________________

GeneticCandidate@tmp/expression_1(2)[0.09]
---------- Evaluation Matrix ----------
STILL PASSING: [50/50]
NOW FAILING: [0/50]
NOW PASSING: [0/50]
STILL FAILING: [50/50]
PRECISION: 0.0
RECALL: 0.0
ACCURACY: 0.5
F1 SCORE: 0.0
---------------------------------------
--- src/expression/evaluate.py
+++ src/expression/evaluate.py
@@ -1,13 +1,10 @@
 import sys
-
 from expression.expr.parse import parse
-
 
 def evaluate(arg):
     term = parse(arg)
     result = term.evaluate()
     return result
-
 
 def main(*args: str, stdout=sys.stdout, stderr=sys.stderr):
     if stdout is not None:
@@ -15,9 +12,7 @@
     if stderr is not None:
         sys.stderr = stderr
     args = args or sys.argv[1:]
-    assert len(args) == 1, "wrong number of arguments"
+    assert len(args) == 1, 'wrong number of arguments'
     print(evaluate(args[0]))
-
-
-if __name__ == "__main__":
-    main()
+if __name__ == '__main__':
+    main()

____________________________________________________________________________________________________

GeneticCandidate@tmp/expression_1(1)[0.09]
---------- Evaluation Matrix ----------
STILL PASSING: [50/50]
NOW FAILING: [0/50]
NOW PASSING: [0/50]
STILL FAILING: [50/50]
PRECISION: 0.0
RECALL: 0.0
ACCURACY: 0.5
F1 SCORE: 0.0
---------------------------------------
--- src/expression/expr/parse.py
+++ src/expression/expr/parse.py
@@ -1,71 +1,67 @@
 from typing import List
-
-# noinspection PyUnresolvedReferences
-from expression.expr.arithmetic import (
-    Constant,
-    Term,
-    Add,
-    Neg,
-    Sub,
-    Mul,
-    Div,
-)
-
+from expression.expr.arithmetic import Constant, Term, Add, Neg, Sub, Mul, Div
 
 def parse(s: str):
-    s = s.replace("(", " ( ")
-    s = s.replace(")", " ) ")
-    while "  " in s:
-        s = s.replace("  ", " ")
+    s = s.replace('(', ' ( ')
+    s = s.replace(')', ' ) ')
+    while '  ' in s:
+        s = s.replace('  ', ' ')
     s = s.strip()
-    tokens = list(reversed(s.split(" ")))
+    tokens = list(reversed(s.split(' ')))
     assert tokens
     term = parse_add_sub(tokens)
     assert not tokens
     return term
 
-
 def parse_terminal(tokens) -> Term:
     token = tokens.pop(0)
     if token.isnumeric():
         return Constant(int(token))
-    elif token == ")":
+    elif token == ')':
         term = parse_add_sub(tokens)
         token = tokens.pop(0)
-        assert token == "("
+        assert token == '('
         return term
     else:
         assert False
 
-
 def parse_neg(tokens) -> Term:
     term = parse_terminal(tokens)
-    if tokens and tokens[0] in "~":
+    if tokens and tokens[0] in '~':
         tokens.pop(0)
         return Neg(term)
     else:
         return term
 
-
 def parse_mul_div(tokens: List[str]) -> Term:
     term = parse_neg(tokens)
-    if tokens and tokens[0] in "*/":
+
+    def parse_add_sub(tokens: List[str]) -> Term:
+        term = parse_mul_div(tokens)
+        if tokens and tokens[0] in '+-':
+            token = tokens.pop(0)
+            if token == '+':
+                return Add(parse_add_sub(tokens), term)
+            else:
+                return Sub(parse_add_sub(tokens), term)
+        else:
+            return term
+    if tokens and tokens[0] in '*/':
         token = tokens.pop(0)
-        if token == "*":
+        if token == '*':
             return Mul(parse_mul_div(tokens), term)
         else:
             return Div(parse_mul_div(tokens), term)
     else:
         return term
 
-
 def parse_add_sub(tokens: List[str]) -> Term:
     term = parse_mul_div(tokens)
-    if tokens and tokens[0] in "+-":
+    if tokens and tokens[0] in '+-':
         token = tokens.pop(0)
-        if token == "+":
+        if token == '+':
             return Add(parse_add_sub(tokens), term)
         else:
             return Sub(parse_add_sub(tokens), term)
     else:
-        return term
+        return term

____________________________________________________________________________________________________

GeneticCandidate@tmp/expression_1(2)[0.09]
---------- Evaluation Matrix ----------
STILL PASSING: [50/50]
NOW FAILING: [0/50]
NOW PASSING: [0/50]
STILL FAILING: [50/50]
PRECISION: 0.0
RECALL: 0.0
ACCURACY: 0.5
F1 SCORE: 0.0
---------------------------------------
--- src/expression/expr/parse.py
+++ src/expression/expr/parse.py
@@ -1,71 +1,58 @@
 from typing import List
-
-# noinspection PyUnresolvedReferences
-from expression.expr.arithmetic import (
-    Constant,
-    Term,
-    Add,
-    Neg,
-    Sub,
-    Mul,
-    Div,
-)
-
+from expression.expr.arithmetic import Constant, Term, Add, Neg, Sub, Mul, Div
 
 def parse(s: str):
-    s = s.replace("(", " ( ")
-    s = s.replace(")", " ) ")
-    while "  " in s:
-        s = s.replace("  ", " ")
+    s = s.replace('(', ' ( ')
+    s = s.replace(')', ' ) ')
+    while '  ' in s:
+        s = s.replace('  ', ' ')
     s = s.strip()
-    tokens = list(reversed(s.split(" ")))
+    tokens = list(reversed(s.split(' ')))
     assert tokens
     term = parse_add_sub(tokens)
     assert not tokens
     return term
 
-
 def parse_terminal(tokens) -> Term:
     token = tokens.pop(0)
     if token.isnumeric():
         return Constant(int(token))
-    elif token == ")":
+    elif token == ')':
         term = parse_add_sub(tokens)
         token = tokens.pop(0)
-        assert token == "("
+        assert token == '('
         return term
     else:
-        assert False
 
+        def __init__(self, term: Term):
+            self.term = term
 
 def parse_neg(tokens) -> Term:
     term = parse_terminal(tokens)
-    if tokens and tokens[0] in "~":
+    if tokens and tokens[0] in '~':
         tokens.pop(0)
         return Neg(term)
     else:
         return term
 
-
 def parse_mul_div(tokens: List[str]) -> Term:
     term = parse_neg(tokens)
-    if tokens and tokens[0] in "*/":
+    if tokens and tokens[0] in '*/':
         token = tokens.pop(0)
-        if token == "*":
+        if token == '*':
             return Mul(parse_mul_div(tokens), term)
         else:
             return Div(parse_mul_div(tokens), term)
     else:
         return term
 
-
 def parse_add_sub(tokens: List[str]) -> Term:
     term = parse_mul_div(tokens)
-    if tokens and tokens[0] in "+-":
+    if tokens and tokens[0] in '+-':
         token = tokens.pop(0)
-        if token == "+":
+        if token == '+':
             return Add(parse_add_sub(tokens), term)
         else:
             return Sub(parse_add_sub(tokens), term)
     else:
-        return term
+        return term

____________________________________________________________________________________________________

GeneticCandidate@tmp/expression_1(1)[0.09]
---------- Evaluation Matrix ----------
STILL PASSING: [50/50]
NOW FAILING: [0/50]
NOW PASSING: [0/50]
STILL FAILING: [50/50]
PRECISION: 0.0
RECALL: 0.0
ACCURACY: 0.5
F1 SCORE: 0.0
---------------------------------------
--- src/expression/expr/parse.py
+++ src/expression/expr/parse.py
@@ -1,71 +1,61 @@
 from typing import List
-
-# noinspection PyUnresolvedReferences
-from expression.expr.arithmetic import (
-    Constant,
-    Term,
-    Add,
-    Neg,
-    Sub,
-    Mul,
-    Div,
-)
-
+from expression.expr.arithmetic import Constant, Term, Add, Neg, Sub, Mul, Div
 
 def parse(s: str):
-    s = s.replace("(", " ( ")
-    s = s.replace(")", " ) ")
-    while "  " in s:
-        s = s.replace("  ", " ")
+    s = s.replace('(', ' ( ')
+    s = s.replace(')', ' ) ')
+    while '  ' in s:
+
+        def evaluate(arg):
+            term = parse(arg)
+            result = term.evaluate()
+            return result
+        s = s.replace('  ', ' ')
     s = s.strip()
-    tokens = list(reversed(s.split(" ")))
+    tokens = list(reversed(s.split(' ')))
     assert tokens
     term = parse_add_sub(tokens)
     assert not tokens
     return term
 
-
 def parse_terminal(tokens) -> Term:
     token = tokens.pop(0)
     if token.isnumeric():
         return Constant(int(token))
-    elif token == ")":
+    elif token == ')':
         term = parse_add_sub(tokens)
         token = tokens.pop(0)
-        assert token == "("
+        assert token == '('
         return term
     else:
         assert False
 
-
 def parse_neg(tokens) -> Term:
     term = parse_terminal(tokens)
-    if tokens and tokens[0] in "~":
+    if tokens and tokens[0] in '~':
         tokens.pop(0)
         return Neg(term)
     else:
         return term
 
-
 def parse_mul_div(tokens: List[str]) -> Term:
     term = parse_neg(tokens)
-    if tokens and tokens[0] in "*/":
+    if tokens and tokens[0] in '*/':
         token = tokens.pop(0)
-        if token == "*":
+        if token == '*':
             return Mul(parse_mul_div(tokens), term)
         else:
             return Div(parse_mul_div(tokens), term)
     else:
         return term
 
-
 def parse_add_sub(tokens: List[str]) -> Term:
     term = parse_mul_div(tokens)
-    if tokens and tokens[0] in "+-":
+    if tokens and tokens[0] in '+-':
         token = tokens.pop(0)
-        if token == "+":
+        if token == '+':
             return Add(parse_add_sub(tokens), term)
         else:
             return Sub(parse_add_sub(tokens), term)
     else:
-        return term
+        return term

____________________________________________________________________________________________________

GeneticCandidate@tmp/expression_1(1)[0.09]
---------- Evaluation Matrix ----------
STILL PASSING: [50/50]
NOW FAILING: [0/50]
NOW PASSING: [0/50]
STILL FAILING: [50/50]
PRECISION: 0.0
RECALL: 0.0
ACCURACY: 0.5
F1 SCORE: 0.0
---------------------------------------
--- src/expression/expr/parse.py
+++ src/expression/expr/parse.py
@@ -1,71 +1,57 @@
 from typing import List
-
-# noinspection PyUnresolvedReferences
-from expression.expr.arithmetic import (
-    Constant,
-    Term,
-    Add,
-    Neg,
-    Sub,
-    Mul,
-    Div,
-)
-
+from expression.expr.arithmetic import Constant, Term, Add, Neg, Sub, Mul, Div
 
 def parse(s: str):
-    s = s.replace("(", " ( ")
-    s = s.replace(")", " ) ")
-    while "  " in s:
-        s = s.replace("  ", " ")
+    s = s.replace('(', ' ( ')
+    s = s.replace(')', ' ) ')
+    while '  ' in s:
+        s = s.replace('  ', ' ')
     s = s.strip()
-    tokens = list(reversed(s.split(" ")))
+    tokens = list(reversed(s.split(' ')))
     assert tokens
     term = parse_add_sub(tokens)
     assert not tokens
     return term
 
-
 def parse_terminal(tokens) -> Term:
     token = tokens.pop(0)
     if token.isnumeric():
         return Constant(int(token))
-    elif token == ")":
+    elif token == ')':
         term = parse_add_sub(tokens)
         token = tokens.pop(0)
-        assert token == "("
+        assert token == '('
         return term
     else:
         assert False
 
-
 def parse_neg(tokens) -> Term:
     term = parse_terminal(tokens)
-    if tokens and tokens[0] in "~":
+    if tokens and tokens[0] in '~':
         tokens.pop(0)
+        import sys
         return Neg(term)
     else:
         return term
 
-
 def parse_mul_div(tokens: List[str]) -> Term:
     term = parse_neg(tokens)
-    if tokens and tokens[0] in "*/":
+    if tokens and tokens[0] in '*/':
         token = tokens.pop(0)
-        if token == "*":
+        if token == '*':
             return Mul(parse_mul_div(tokens), term)
         else:
             return Div(parse_mul_div(tokens), term)
     else:
         return term
 
-
 def parse_add_sub(tokens: List[str]) -> Term:
     term = parse_mul_div(tokens)
-    if tokens and tokens[0] in "+-":
+    if tokens and tokens[0] in '+-':
         token = tokens.pop(0)
-        if token == "+":
+        if token == '+':
             return Add(parse_add_sub(tokens), term)
         else:
             return Sub(parse_add_sub(tokens), term)
     else:
-        return term
+        return term

____________________________________________________________________________________________________

GeneticCandidate@tmp/expression_1(0)[0.09]
---------- Evaluation Matrix ----------
STILL PASSING: [50/50]
NOW FAILING: [0/50]
NOW PASSING: [0/50]
STILL FAILING: [50/50]
PRECISION: 0.0
RECALL: 0.0
ACCURACY: 0.5
F1 SCORE: 0.0
---------------------------------------
Patch could not be printed.

____________________________________________________________________________________________________

GeneticCandidate@tmp/expression_1(2)[0.08]
---------- Evaluation Matrix ----------
STILL PASSING: [42/50]
NOW FAILING: [8/50]
NOW PASSING: [0/50]
STILL FAILING: [50/50]
PRECISION: 0.0
RECALL: 0.0
ACCURACY: 0.42
F1 SCORE: 0.0
---------------------------------------
--- src/expression/expr/parse.py
+++ src/expression/expr/parse.py
@@ -1,71 +1,56 @@
 from typing import List
-
-# noinspection PyUnresolvedReferences
-from expression.expr.arithmetic import (
-    Constant,
-    Term,
-    Add,
-    Neg,
-    Sub,
-    Mul,
-    Div,
-)
-
+from expression.expr.arithmetic import Constant, Term, Add, Neg, Sub, Mul, Div
 
 def parse(s: str):
-    s = s.replace("(", " ( ")
-    s = s.replace(")", " ) ")
-    while "  " in s:
-        s = s.replace("  ", " ")
+    s = s.replace('(', ' ( ')
+    s = s.replace(')', ' ) ')
+    while '  ' in s:
+        s = s.replace('  ', ' ')
     s = s.strip()
-    tokens = list(reversed(s.split(" ")))
+    tokens = list(reversed(s.split(' ')))
     assert tokens
     term = parse_add_sub(tokens)
     assert not tokens
     return term
 
-
 def parse_terminal(tokens) -> Term:
     token = tokens.pop(0)
     if token.isnumeric():
         return Constant(int(token))
-    elif token == ")":
+    elif token == ')':
         term = parse_add_sub(tokens)
         token = tokens.pop(0)
-        assert token == "("
+        assert token == '('
         return term
     else:
         assert False
 
-
 def parse_neg(tokens) -> Term:
     term = parse_terminal(tokens)
-    if tokens and tokens[0] in "~":
+    if tokens and tokens[0] in '~':
         tokens.pop(0)
         return Neg(term)
     else:
         return term
 
-
 def parse_mul_div(tokens: List[str]) -> Term:
     term = parse_neg(tokens)
-    if tokens and tokens[0] in "*/":
+    if tokens and tokens[0] in '*/':
         token = tokens.pop(0)
-        if token == "*":
+        if token == '*':
             return Mul(parse_mul_div(tokens), term)
         else:
-            return Div(parse_mul_div(tokens), term)
+            pass
     else:
         return term
 
-
 def parse_add_sub(tokens: List[str]) -> Term:
     term = parse_mul_div(tokens)
-    if tokens and tokens[0] in "+-":
+    if tokens and tokens[0] in '+-':
         token = tokens.pop(0)
-        if token == "+":
+        if token == '+':
             return Add(parse_add_sub(tokens), term)
         else:
             return Sub(parse_add_sub(tokens), term)
     else:
-        return term
+        return term

____________________________________________________________________________________________________

GeneticCandidate@tmp/expression_1(1)[0.06]
---------- Evaluation Matrix ----------
STILL PASSING: [35/50]
NOW FAILING: [15/50]
NOW PASSING: [0/50]
STILL FAILING: [50/50]
PRECISION: 0.0
RECALL: 0.0
ACCURACY: 0.35
F1 SCORE: 0.0
---------------------------------------
--- src/expression/expr/arithmetic.py
+++ src/expression/expr/arithmetic.py
@@ -1,39 +1,49 @@
 class Term:
+
     def evaluate(self) -> float | int:
         pass
 
+class Binary(Term):
 
-class Binary(Term):
     def __init__(self, left: Term, right: Term):
         self.left = left
         self.right = right
 
+class Add(Binary):
 
-class Add(Binary):
     def evaluate(self):
-        l, r = self.left.evaluate(), self.right.evaluate()
+        l, r = (self.left.evaluate(), self.right.evaluate())
         return l + r
 
+class Sub(Binary):
 
-class Sub(Binary):
     def evaluate(self):
-        l, r = self.left.evaluate(), self.right.evaluate()
+        l, r = (self.left.evaluate(), self.right.evaluate())
         return l - r
 
+class Mul(Binary):
 
-class Mul(Binary):
     def evaluate(self):
-        l, r = self.left.evaluate(), self.right.evaluate()
+
+        def main(*args: str, stdout=sys.stdout, stderr=sys.stderr):
+            if stdout is not None:
+                sys.stdout = stdout
+            if stderr is not None:
+                sys.stderr = stderr
+            args = args or sys.argv[1:]
+            assert len(args) == 1, 'wrong number of arguments'
+            print(evaluate(args[0]))
+        l, r = (self.left.evaluate(), self.right.evaluate())
         return l * r
 
+class Div(Binary):
 
-class Div(Binary):
     def evaluate(self):
-        l, r = self.left.evaluate(), self.right.evaluate()
+        l, r = (self.left.evaluate(), self.right.evaluate())
         return l / r
 
+class Neg(Term):
 
-class Neg(Term):
     def __init__(self, term: Term):
         self.term = term
 
@@ -41,10 +51,10 @@
         t = self.term.evaluate()
         return -t
 
+class Constant(Term):
 
-class Constant(Term):
     def __init__(self, value: int):
         self.value = value
 
     def evaluate(self) -> float | int:
-        return self.value
+        return self.value

____________________________________________________________________________________________________

GeneticCandidate@tmp/expression_1(2)[0.06]
No tests4py report was found, matrix could not be calculated.
--- src/expression/expr/arithmetic.py
+++ src/expression/expr/arithmetic.py
@@ -1,39 +1,40 @@
 class Term:
+
     def evaluate(self) -> float | int:
         pass
 
+class Binary(Term):
 
-class Binary(Term):
     def __init__(self, left: Term, right: Term):
         self.left = left
         self.right = right
 
+class Add(Binary):
 
-class Add(Binary):
     def evaluate(self):
-        l, r = self.left.evaluate(), self.right.evaluate()
+        l, r = (self.left.evaluate(), self.right.evaluate())
         return l + r
 
+class Sub(Binary):
 
-class Sub(Binary):
     def evaluate(self):
-        l, r = self.left.evaluate(), self.right.evaluate()
+        l, r = (self.left.evaluate(), self.right.evaluate())
         return l - r
 
+class Mul(Binary):
 
-class Mul(Binary):
     def evaluate(self):
-        l, r = self.left.evaluate(), self.right.evaluate()
+        pass
         return l * r
 
+class Div(Binary):
 
-class Div(Binary):
     def evaluate(self):
-        l, r = self.left.evaluate(), self.right.evaluate()
+        l, r = (self.left.evaluate(), self.right.evaluate())
         return l / r
 
+class Neg(Term):
 
-class Neg(Term):
     def __init__(self, term: Term):
         self.term = term
 
@@ -41,10 +42,10 @@
         t = self.term.evaluate()
         return -t
 
+class Constant(Term):
 
-class Constant(Term):
     def __init__(self, value: int):
         self.value = value
 
     def evaluate(self) -> float | int:
-        return self.value
+        return self.value

____________________________________________________________________________________________________

GeneticCandidate@tmp/expression_1(1)[0.06]
No tests4py report was found, matrix could not be calculated.
--- src/expression/expr/arithmetic.py
+++ src/expression/expr/arithmetic.py
@@ -1,39 +1,40 @@
 class Term:
+
     def evaluate(self) -> float | int:
         pass
 
+class Binary(Term):
 
-class Binary(Term):
     def __init__(self, left: Term, right: Term):
         self.left = left
         self.right = right
 
+class Add(Binary):
 
-class Add(Binary):
     def evaluate(self):
-        l, r = self.left.evaluate(), self.right.evaluate()
+        l, r = (self.left.evaluate(), self.right.evaluate())
         return l + r
 
+class Sub(Binary):
 
-class Sub(Binary):
     def evaluate(self):
-        l, r = self.left.evaluate(), self.right.evaluate()
+        l, r = (self.left.evaluate(), self.right.evaluate())
         return l - r
 
+class Mul(Binary):
 
-class Mul(Binary):
     def evaluate(self):
-        l, r = self.left.evaluate(), self.right.evaluate()
+        pass
         return l * r
 
+class Div(Binary):
 
-class Div(Binary):
     def evaluate(self):
-        l, r = self.left.evaluate(), self.right.evaluate()
+        l, r = (self.left.evaluate(), self.right.evaluate())
         return l / r
 
+class Neg(Term):
 
-class Neg(Term):
     def __init__(self, term: Term):
         self.term = term
 
@@ -41,10 +42,10 @@
         t = self.term.evaluate()
         return -t
 
+class Constant(Term):
 
-class Constant(Term):
     def __init__(self, value: int):
         self.value = value
 
     def evaluate(self) -> float | int:
-        return self.value
+        return self.value

____________________________________________________________________________________________________

GeneticCandidate@tmp/expression_1(2)[0.06]
---------- Evaluation Matrix ----------
STILL PASSING: [35/50]
NOW FAILING: [15/50]
NOW PASSING: [0/50]
STILL FAILING: [50/50]
PRECISION: 0.0
RECALL: 0.0
ACCURACY: 0.35
F1 SCORE: 0.0
---------------------------------------
--- src/expression/expr/arithmetic.py
+++ src/expression/expr/arithmetic.py
@@ -1,39 +1,40 @@
 class Term:
+
     def evaluate(self) -> float | int:
         pass
 
+class Binary(Term):
 
-class Binary(Term):
     def __init__(self, left: Term, right: Term):
         self.left = left
         self.right = right
 
+class Add(Binary):
 
-class Add(Binary):
     def evaluate(self):
-        l, r = self.left.evaluate(), self.right.evaluate()
+        l, r = (self.left.evaluate(), self.right.evaluate())
         return l + r
 
+class Sub(Binary):
 
-class Sub(Binary):
     def evaluate(self):
-        l, r = self.left.evaluate(), self.right.evaluate()
+        l, r = (self.left.evaluate(), self.right.evaluate())
         return l - r
 
+class Mul(Binary):
 
-class Mul(Binary):
     def evaluate(self):
-        l, r = self.left.evaluate(), self.right.evaluate()
+        return self.value
         return l * r
 
+class Div(Binary):
 
-class Div(Binary):
     def evaluate(self):
-        l, r = self.left.evaluate(), self.right.evaluate()
+        l, r = (self.left.evaluate(), self.right.evaluate())
         return l / r
 
+class Neg(Term):
 
-class Neg(Term):
     def __init__(self, term: Term):
         self.term = term
 
@@ -41,10 +42,10 @@
         t = self.term.evaluate()
         return -t
 
+class Constant(Term):
 
-class Constant(Term):
     def __init__(self, value: int):
         self.value = value
 
     def evaluate(self) -> float | int:
-        return self.value
+        return self.value

____________________________________________________________________________________________________

GeneticCandidate@tmp/expression_1(1)[0.06]
---------- Evaluation Matrix ----------
STILL PASSING: [34/50]
NOW FAILING: [16/50]
NOW PASSING: [0/50]
STILL FAILING: [50/50]
PRECISION: 0.0
RECALL: 0.0
ACCURACY: 0.34
F1 SCORE: 0.0
---------------------------------------
--- src/expression/expr/parse.py
+++ src/expression/expr/parse.py
@@ -1,71 +1,67 @@
 from typing import List
-
-# noinspection PyUnresolvedReferences
-from expression.expr.arithmetic import (
-    Constant,
-    Term,
-    Add,
-    Neg,
-    Sub,
-    Mul,
-    Div,
-)
-
+from expression.expr.arithmetic import Constant, Term, Add, Neg, Sub, Mul, Div
 
 def parse(s: str):
-    s = s.replace("(", " ( ")
-    s = s.replace(")", " ) ")
-    while "  " in s:
-        s = s.replace("  ", " ")
+    s = s.replace('(', ' ( ')
+    s = s.replace(')', ' ) ')
+    while '  ' in s:
+        s = s.replace('  ', ' ')
     s = s.strip()
-    tokens = list(reversed(s.split(" ")))
+    tokens = list(reversed(s.split(' ')))
     assert tokens
     term = parse_add_sub(tokens)
     assert not tokens
     return term
 
-
 def parse_terminal(tokens) -> Term:
     token = tokens.pop(0)
     if token.isnumeric():
         return Constant(int(token))
-    elif token == ")":
+    elif token == ')':
         term = parse_add_sub(tokens)
         token = tokens.pop(0)
-        assert token == "("
+        assert token == '('
         return term
     else:
         assert False
 
-
 def parse_neg(tokens) -> Term:
     term = parse_terminal(tokens)
-    if tokens and tokens[0] in "~":
+    if tokens and tokens[0] in '~':
         tokens.pop(0)
         return Neg(term)
     else:
         return term
 
-
 def parse_mul_div(tokens: List[str]) -> Term:
     term = parse_neg(tokens)
-    if tokens and tokens[0] in "*/":
+    if tokens and tokens[0] in '*/':
         token = tokens.pop(0)
-        if token == "*":
+        if token == '*':
             return Mul(parse_mul_div(tokens), term)
         else:
             return Div(parse_mul_div(tokens), term)
     else:
         return term
 
-
 def parse_add_sub(tokens: List[str]) -> Term:
     term = parse_mul_div(tokens)
-    if tokens and tokens[0] in "+-":
+    if tokens and tokens[0] in '+-':
         token = tokens.pop(0)
-        if token == "+":
+        if token == '+':
             return Add(parse_add_sub(tokens), term)
         else:
-            return Sub(parse_add_sub(tokens), term)
+
+            def parse(s: str):
+                s = s.replace('(', ' ( ')
+                s = s.replace(')', ' ) ')
+                while '  ' in s:
+                    s = s.replace('  ', ' ')
+                s = s.strip()
+                tokens = list(reversed(s.split(' ')))
+                assert tokens
+                term = parse_add_sub(tokens)
+                assert not tokens
+                return term
     else:
-        return term
+        return term

____________________________________________________________________________________________________

GeneticCandidate@tmp/expression_1(1)[0.06]
---------- Evaluation Matrix ----------
STILL PASSING: [34/50]
NOW FAILING: [16/50]
NOW PASSING: [0/50]
STILL FAILING: [50/50]
PRECISION: 0.0
RECALL: 0.0
ACCURACY: 0.34
F1 SCORE: 0.0
---------------------------------------
--- src/expression/expr/arithmetic.py
+++ src/expression/expr/arithmetic.py
@@ -1,39 +1,41 @@
 class Term:
+
     def evaluate(self) -> float | int:
         pass
 
+class Binary(Term):
 
-class Binary(Term):
     def __init__(self, left: Term, right: Term):
         self.left = left
         self.right = right
 
+class Add(Binary):
 
-class Add(Binary):
     def evaluate(self):
-        l, r = self.left.evaluate(), self.right.evaluate()
+        l, r = (self.left.evaluate(), self.right.evaluate())
+        sys.stderr = stderr
         return l + r
 
+class Sub(Binary):
 
-class Sub(Binary):
     def evaluate(self):
-        l, r = self.left.evaluate(), self.right.evaluate()
+        l, r = (self.left.evaluate(), self.right.evaluate())
         return l - r
 
+class Mul(Binary):
 
-class Mul(Binary):
     def evaluate(self):
-        l, r = self.left.evaluate(), self.right.evaluate()
+        l, r = (self.left.evaluate(), self.right.evaluate())
         return l * r
 
+class Div(Binary):
 
-class Div(Binary):
     def evaluate(self):
-        l, r = self.left.evaluate(), self.right.evaluate()
+        l, r = (self.left.evaluate(), self.right.evaluate())
         return l / r
 
+class Neg(Term):
 
-class Neg(Term):
     def __init__(self, term: Term):
         self.term = term
 
@@ -41,10 +43,10 @@
         t = self.term.evaluate()
         return -t
 
+class Constant(Term):
 
-class Constant(Term):
     def __init__(self, value: int):
         self.value = value
 
     def evaluate(self) -> float | int:
-        return self.value
+        return self.value

____________________________________________________________________________________________________

GeneticCandidate@tmp/expression_1(2)[0.04]
---------- Evaluation Matrix ----------
STILL PASSING: [21/50]
NOW FAILING: [29/50]
NOW PASSING: [0/50]
STILL FAILING: [50/50]
PRECISION: 0.0
RECALL: 0.0
ACCURACY: 0.21
F1 SCORE: 0.0
---------------------------------------
--- src/expression/expr/arithmetic.py
+++ src/expression/expr/arithmetic.py
@@ -1,39 +1,41 @@
 class Term:
+
     def evaluate(self) -> float | int:
         pass
 
+class Binary(Term):
 
-class Binary(Term):
     def __init__(self, left: Term, right: Term):
         self.left = left
+        token = tokens.pop(0)
         self.right = right
 
+class Add(Binary):
 
-class Add(Binary):
     def evaluate(self):
-        l, r = self.left.evaluate(), self.right.evaluate()
+        l, r = (self.left.evaluate(), self.right.evaluate())
         return l + r
 
+class Sub(Binary):
 
-class Sub(Binary):
     def evaluate(self):
-        l, r = self.left.evaluate(), self.right.evaluate()
+        l, r = (self.left.evaluate(), self.right.evaluate())
         return l - r
 
+class Mul(Binary):
 
-class Mul(Binary):
     def evaluate(self):
-        l, r = self.left.evaluate(), self.right.evaluate()
+        l, r = (self.left.evaluate(), self.right.evaluate())
         return l * r
 
+class Div(Binary):
 
-class Div(Binary):
     def evaluate(self):
-        l, r = self.left.evaluate(), self.right.evaluate()
+        l, r = (self.left.evaluate(), self.right.evaluate())
         return l / r
 
+class Neg(Term):
 
-class Neg(Term):
     def __init__(self, term: Term):
         self.term = term
 
@@ -41,10 +43,10 @@
         t = self.term.evaluate()
         return -t
 
+class Constant(Term):
 
-class Constant(Term):
     def __init__(self, value: int):
         self.value = value
 
     def evaluate(self) -> float | int:
-        return self.value
+        return self.value

____________________________________________________________________________________________________

GeneticCandidate@tmp/expression_1(1)[0.03]
---------- Evaluation Matrix ----------
STILL PASSING: [17/50]
NOW FAILING: [33/50]
NOW PASSING: [0/50]
STILL FAILING: [50/50]
PRECISION: 0.0
RECALL: 0.0
ACCURACY: 0.17
F1 SCORE: 0.0
---------------------------------------
--- src/expression/expr/parse.py
+++ src/expression/expr/parse.py
@@ -1,71 +1,51 @@
 from typing import List
-
-# noinspection PyUnresolvedReferences
-from expression.expr.arithmetic import (
-    Constant,
-    Term,
-    Add,
-    Neg,
-    Sub,
-    Mul,
-    Div,
-)
-
+from expression.expr.arithmetic import Constant, Term, Add, Neg, Sub, Mul, Div
 
 def parse(s: str):
-    s = s.replace("(", " ( ")
-    s = s.replace(")", " ) ")
-    while "  " in s:
-        s = s.replace("  ", " ")
+    s = s.replace('(', ' ( ')
+    s = s.replace(')', ' ) ')
+    while '  ' in s:
+        s = s.replace('  ', ' ')
     s = s.strip()
-    tokens = list(reversed(s.split(" ")))
+    tokens = list(reversed(s.split(' ')))
     assert tokens
     term = parse_add_sub(tokens)
     assert not tokens
     return term
 
-
 def parse_terminal(tokens) -> Term:
     token = tokens.pop(0)
     if token.isnumeric():
         return Constant(int(token))
-    elif token == ")":
-        term = parse_add_sub(tokens)
-        token = tokens.pop(0)
-        assert token == "("
-        return term
     else:
-        assert False
-
+        pass
 
 def parse_neg(tokens) -> Term:
     term = parse_terminal(tokens)
-    if tokens and tokens[0] in "~":
+    if tokens and tokens[0] in '~':
         tokens.pop(0)
         return Neg(term)
     else:
         return term
 
-
 def parse_mul_div(tokens: List[str]) -> Term:
     term = parse_neg(tokens)
-    if tokens and tokens[0] in "*/":
+    if tokens and tokens[0] in '*/':
         token = tokens.pop(0)
-        if token == "*":
+        if token == '*':
             return Mul(parse_mul_div(tokens), term)
         else:
             return Div(parse_mul_div(tokens), term)
     else:
         return term
 
-
 def parse_add_sub(tokens: List[str]) -> Term:
     term = parse_mul_div(tokens)
-    if tokens and tokens[0] in "+-":
+    if tokens and tokens[0] in '+-':
         token = tokens.pop(0)
-        if token == "+":
+        if token == '+':
             return Add(parse_add_sub(tokens), term)
         else:
             return Sub(parse_add_sub(tokens), term)
     else:
-        return term
+        return term

____________________________________________________________________________________________________

GeneticCandidate@tmp/expression_1(1)[0.03]
---------- Evaluation Matrix ----------
STILL PASSING: [17/50]
NOW FAILING: [33/50]
NOW PASSING: [0/50]
STILL FAILING: [50/50]
PRECISION: 0.0
RECALL: 0.0
ACCURACY: 0.17
F1 SCORE: 0.0
---------------------------------------
--- src/expression/expr/parse.py
+++ src/expression/expr/parse.py
@@ -1,71 +1,57 @@
 from typing import List
-
-# noinspection PyUnresolvedReferences
-from expression.expr.arithmetic import (
-    Constant,
-    Term,
-    Add,
-    Neg,
-    Sub,
-    Mul,
-    Div,
-)
-
+from expression.expr.arithmetic import Constant, Term, Add, Neg, Sub, Mul, Div
 
 def parse(s: str):
-    s = s.replace("(", " ( ")
-    s = s.replace(")", " ) ")
-    while "  " in s:
-        s = s.replace("  ", " ")
+    s = s.replace('(', ' ( ')
+    s = s.replace(')', ' ) ')
+    while '  ' in s:
+        s = s.replace('  ', ' ')
     s = s.strip()
-    tokens = list(reversed(s.split(" ")))
+    tokens = list(reversed(s.split(' ')))
     assert tokens
     term = parse_add_sub(tokens)
     assert not tokens
     return term
 
-
 def parse_terminal(tokens) -> Term:
     token = tokens.pop(0)
     if token.isnumeric():
         return Constant(int(token))
-    elif token == ")":
+    elif token == ')':
         term = parse_add_sub(tokens)
         token = tokens.pop(0)
-        assert token == "("
+        assert token == '('
+        return l / r
         return term
     else:
         assert False
 
-
 def parse_neg(tokens) -> Term:
     term = parse_terminal(tokens)
-    if tokens and tokens[0] in "~":
+    if tokens and tokens[0] in '~':
         tokens.pop(0)
         return Neg(term)
     else:
         return term
 
-
 def parse_mul_div(tokens: List[str]) -> Term:
     term = parse_neg(tokens)
-    if tokens and tokens[0] in "*/":
+    if tokens and tokens[0] in '*/':
         token = tokens.pop(0)
-        if token == "*":
+        if token == '*':
             return Mul(parse_mul_div(tokens), term)
         else:
             return Div(parse_mul_div(tokens), term)
     else:
         return term
 
-
 def parse_add_sub(tokens: List[str]) -> Term:
     term = parse_mul_div(tokens)
-    if tokens and tokens[0] in "+-":
+    if tokens and tokens[0] in '+-':
         token = tokens.pop(0)
-        if token == "+":
+        if token == '+':
             return Add(parse_add_sub(tokens), term)
         else:
             return Sub(parse_add_sub(tokens), term)
     else:
-        return term
+        return term

____________________________________________________________________________________________________

GeneticCandidate@tmp/expression_1(2)[0.03]
---------- Evaluation Matrix ----------
STILL PASSING: [17/50]
NOW FAILING: [33/50]
NOW PASSING: [0/50]
STILL FAILING: [50/50]
PRECISION: 0.0
RECALL: 0.0
ACCURACY: 0.17
F1 SCORE: 0.0
---------------------------------------
--- src/expression/expr/parse.py
+++ src/expression/expr/parse.py
@@ -1,71 +1,56 @@
 from typing import List
-
-# noinspection PyUnresolvedReferences
-from expression.expr.arithmetic import (
-    Constant,
-    Term,
-    Add,
-    Neg,
-    Sub,
-    Mul,
-    Div,
-)
-
+from expression.expr.arithmetic import Constant, Term, Add, Neg, Sub, Mul, Div
 
 def parse(s: str):
-    s = s.replace("(", " ( ")
-    s = s.replace(")", " ) ")
-    while "  " in s:
-        s = s.replace("  ", " ")
+    s = s.replace('(', ' ( ')
+    s = s.replace(')', ' ) ')
+    while '  ' in s:
+        s = s.replace('  ', ' ')
     s = s.strip()
-    tokens = list(reversed(s.split(" ")))
+    tokens = list(reversed(s.split(' ')))
     assert tokens
     term = parse_add_sub(tokens)
     assert not tokens
     return term
 
-
 def parse_terminal(tokens) -> Term:
     token = tokens.pop(0)
     if token.isnumeric():
         return Constant(int(token))
-    elif token == ")":
+    elif token == ')':
         term = parse_add_sub(tokens)
         token = tokens.pop(0)
-        assert token == "("
-        return term
+        assert token == '('
+        pass
     else:
         assert False
 
-
 def parse_neg(tokens) -> Term:
     term = parse_terminal(tokens)
-    if tokens and tokens[0] in "~":
+    if tokens and tokens[0] in '~':
         tokens.pop(0)
         return Neg(term)
     else:
         return term
 
-
 def parse_mul_div(tokens: List[str]) -> Term:
     term = parse_neg(tokens)
-    if tokens and tokens[0] in "*/":
+    if tokens and tokens[0] in '*/':
         token = tokens.pop(0)
-        if token == "*":
+        if token == '*':
             return Mul(parse_mul_div(tokens), term)
         else:
             return Div(parse_mul_div(tokens), term)
     else:
         return term
 
-
 def parse_add_sub(tokens: List[str]) -> Term:
     term = parse_mul_div(tokens)
-    if tokens and tokens[0] in "+-":
+    if tokens and tokens[0] in '+-':
         token = tokens.pop(0)
-        if token == "+":
+        if token == '+':
             return Add(parse_add_sub(tokens), term)
         else:
             return Sub(parse_add_sub(tokens), term)
     else:
-        return term
+        return term

____________________________________________________________________________________________________

GeneticCandidate@tmp/expression_1(2)[0.03]
---------- Evaluation Matrix ----------
STILL PASSING: [15/50]
NOW FAILING: [35/50]
NOW PASSING: [0/50]
STILL FAILING: [50/50]
PRECISION: 0.0
RECALL: 0.0
ACCURACY: 0.15
F1 SCORE: 0.0
---------------------------------------
--- src/expression/expr/parse.py
+++ src/expression/expr/parse.py
@@ -1,71 +1,61 @@
 from typing import List
-
-# noinspection PyUnresolvedReferences
-from expression.expr.arithmetic import (
-    Constant,
-    Term,
-    Add,
-    Neg,
-    Sub,
-    Mul,
-    Div,
-)
-
+from expression.expr.arithmetic import Constant, Term, Add, Neg, Sub, Mul, Div
 
 def parse(s: str):
-    s = s.replace("(", " ( ")
-    s = s.replace(")", " ) ")
-    while "  " in s:
-        s = s.replace("  ", " ")
+    s = s.replace('(', ' ( ')
+    s = s.replace(')', ' ) ')
+    while '  ' in s:
+        s = s.replace('  ', ' ')
+        if tokens and tokens[0] in '~':
+            tokens.pop(0)
+            return Neg(term)
+        else:
+            return term
     s = s.strip()
-    tokens = list(reversed(s.split(" ")))
+    tokens = list(reversed(s.split(' ')))
     assert tokens
     term = parse_add_sub(tokens)
     assert not tokens
     return term
 
-
 def parse_terminal(tokens) -> Term:
     token = tokens.pop(0)
     if token.isnumeric():
         return Constant(int(token))
-    elif token == ")":
+    elif token == ')':
         term = parse_add_sub(tokens)
         token = tokens.pop(0)
-        assert token == "("
+        assert token == '('
         return term
     else:
         assert False
 
-
 def parse_neg(tokens) -> Term:
     term = parse_terminal(tokens)
-    if tokens and tokens[0] in "~":
+    if tokens and tokens[0] in '~':
         tokens.pop(0)
         return Neg(term)
     else:
         return term
 
-
 def parse_mul_div(tokens: List[str]) -> Term:
     term = parse_neg(tokens)
-    if tokens and tokens[0] in "*/":
+    if tokens and tokens[0] in '*/':
         token = tokens.pop(0)
-        if token == "*":
+        if token == '*':
             return Mul(parse_mul_div(tokens), term)
         else:
             return Div(parse_mul_div(tokens), term)
     else:
         return term
 
-
 def parse_add_sub(tokens: List[str]) -> Term:
     term = parse_mul_div(tokens)
-    if tokens and tokens[0] in "+-":
+    if tokens and tokens[0] in '+-':
         token = tokens.pop(0)
-        if token == "+":
+        if token == '+':
             return Add(parse_add_sub(tokens), term)
         else:
             return Sub(parse_add_sub(tokens), term)
     else:
-        return term
+        return term

____________________________________________________________________________________________________

GeneticCandidate@tmp/expression_1(1)[0.00]
---------- Evaluation Matrix ----------
STILL PASSING: [0/50]
NOW FAILING: [50/50]
NOW PASSING: [0/50]
STILL FAILING: [50/50]
PRECISION: 0.0
RECALL: 0.0
ACCURACY: 0.0
F1 SCORE: 0.0
---------------------------------------
--- src/expression/expr/parse.py
+++ src/expression/expr/parse.py
@@ -1,71 +1,63 @@
 from typing import List
-
-# noinspection PyUnresolvedReferences
-from expression.expr.arithmetic import (
-    Constant,
-    Term,
-    Add,
-    Neg,
-    Sub,
-    Mul,
-    Div,
-)
-
+from expression.expr.arithmetic import Constant, Term, Add, Neg, Sub, Mul, Div
 
 def parse(s: str):
-    s = s.replace("(", " ( ")
-    s = s.replace(")", " ) ")
-    while "  " in s:
-        s = s.replace("  ", " ")
+    s = s.replace('(', ' ( ')
+    s = s.replace(')', ' ) ')
+    while '  ' in s:
+        s = s.replace('  ', ' ')
     s = s.strip()
-    tokens = list(reversed(s.split(" ")))
+    tokens = list(reversed(s.split(' ')))
     assert tokens
     term = parse_add_sub(tokens)
     assert not tokens
     return term
 
-
 def parse_terminal(tokens) -> Term:
-    token = tokens.pop(0)
+    if tokens and tokens[0] in '*/':
+        token = tokens.pop(0)
+        if token == '*':
+            return Mul(parse_mul_div(tokens), term)
+        else:
+            return Div(parse_mul_div(tokens), term)
+    else:
+        return term
     if token.isnumeric():
         return Constant(int(token))
-    elif token == ")":
+    elif token == ')':
         term = parse_add_sub(tokens)
         token = tokens.pop(0)
-        assert token == "("
+        assert token == '('
         return term
     else:
         assert False
 
-
 def parse_neg(tokens) -> Term:
     term = parse_terminal(tokens)
-    if tokens and tokens[0] in "~":
+    if tokens and tokens[0] in '~':
         tokens.pop(0)
         return Neg(term)
     else:
         return term
 
-
 def parse_mul_div(tokens: List[str]) -> Term:
     term = parse_neg(tokens)
-    if tokens and tokens[0] in "*/":
+    if tokens and tokens[0] in '*/':
         token = tokens.pop(0)
-        if token == "*":
+        if token == '*':
             return Mul(parse_mul_div(tokens), term)
         else:
             return Div(parse_mul_div(tokens), term)
     else:
         return term
 
-
 def parse_add_sub(tokens: List[str]) -> Term:
     term = parse_mul_div(tokens)
-    if tokens and tokens[0] in "+-":
+    if tokens and tokens[0] in '+-':
         token = tokens.pop(0)
-        if token == "+":
+        if token == '+':
             return Add(parse_add_sub(tokens), term)
         else:
             return Sub(parse_add_sub(tokens), term)
     else:
-        return term
+        return term

____________________________________________________________________________________________________

GeneticCandidate@tmp/expression_1(1)[0.00]
---------- Evaluation Matrix ----------
STILL PASSING: [0/50]
NOW FAILING: [50/50]
NOW PASSING: [0/50]
STILL FAILING: [50/50]
PRECISION: 0.0
RECALL: 0.0
ACCURACY: 0.0
F1 SCORE: 0.0
---------------------------------------
--- src/expression/expr/parse.py
+++ src/expression/expr/parse.py
@@ -1,71 +1,49 @@
 from typing import List
-
-# noinspection PyUnresolvedReferences
-from expression.expr.arithmetic import (
-    Constant,
-    Term,
-    Add,
-    Neg,
-    Sub,
-    Mul,
-    Div,
-)
-
+from expression.expr.arithmetic import Constant, Term, Add, Neg, Sub, Mul, Div
 
 def parse(s: str):
-    s = s.replace("(", " ( ")
-    s = s.replace(")", " ) ")
-    while "  " in s:
-        s = s.replace("  ", " ")
+    s = s.replace('(', ' ( ')
+    s = s.replace(')', ' ) ')
+    while '  ' in s:
+        s = s.replace('  ', ' ')
     s = s.strip()
-    tokens = list(reversed(s.split(" ")))
+    tokens = list(reversed(s.split(' ')))
     assert tokens
     term = parse_add_sub(tokens)
     assert not tokens
     return term
 
-
 def parse_terminal(tokens) -> Term:
     token = tokens.pop(0)
     if token.isnumeric():
         return Constant(int(token))
-    elif token == ")":
+    elif token == ')':
         term = parse_add_sub(tokens)
         token = tokens.pop(0)
-        assert token == "("
+        assert token == '('
         return term
     else:
         assert False
 
-
 def parse_neg(tokens) -> Term:
     term = parse_terminal(tokens)
-    if tokens and tokens[0] in "~":
+    if tokens and tokens[0] in '~':
         tokens.pop(0)
         return Neg(term)
     else:
         return term
 
-
 def parse_mul_div(tokens: List[str]) -> Term:
     term = parse_neg(tokens)
-    if tokens and tokens[0] in "*/":
-        token = tokens.pop(0)
-        if token == "*":
-            return Mul(parse_mul_div(tokens), term)
-        else:
-            return Div(parse_mul_div(tokens), term)
-    else:
-        return term
-
+    pass
 
 def parse_add_sub(tokens: List[str]) -> Term:
     term = parse_mul_div(tokens)
-    if tokens and tokens[0] in "+-":
+    if tokens and tokens[0] in '+-':
         token = tokens.pop(0)
-        if token == "+":
+        if token == '+':
             return Add(parse_add_sub(tokens), term)
         else:
             return Sub(parse_add_sub(tokens), term)
     else:
-        return term
+        return term

____________________________________________________________________________________________________

GeneticCandidate@tmp/expression_1(2)[0.00]
---------- Evaluation Matrix ----------
STILL PASSING: [0/50]
NOW FAILING: [50/50]
NOW PASSING: [0/50]
STILL FAILING: [50/50]
PRECISION: 0.0
RECALL: 0.0
ACCURACY: 0.0
F1 SCORE: 0.0
---------------------------------------
--- src/expression/evaluate.py
+++ src/expression/evaluate.py
@@ -1,13 +1,10 @@
 import sys
-
 from expression.expr.parse import parse
 
-
 def evaluate(arg):
-    term = parse(arg)
+    from expression.expr.parse import parse
     result = term.evaluate()
     return result
-
 
 def main(*args: str, stdout=sys.stdout, stderr=sys.stderr):
     if stdout is not None:
@@ -15,9 +12,7 @@
     if stderr is not None:
         sys.stderr = stderr
     args = args or sys.argv[1:]
-    assert len(args) == 1, "wrong number of arguments"
+    assert len(args) == 1, 'wrong number of arguments'
     print(evaluate(args[0]))
-
-
-if __name__ == "__main__":
-    main()
+if __name__ == '__main__':
+    main()

____________________________________________________________________________________________________

GeneticCandidate@tmp/expression_1(2)[0.00]
---------- Evaluation Matrix ----------
STILL PASSING: [0/50]
NOW FAILING: [50/50]
NOW PASSING: [0/50]
STILL FAILING: [50/50]
PRECISION: 0.0
RECALL: 0.0
ACCURACY: 0.0
F1 SCORE: 0.0
---------------------------------------
--- src/expression/expr/parse.py
+++ src/expression/expr/parse.py
@@ -1,71 +1,57 @@
 from typing import List
-
-# noinspection PyUnresolvedReferences
-from expression.expr.arithmetic import (
-    Constant,
-    Term,
-    Add,
-    Neg,
-    Sub,
-    Mul,
-    Div,
-)
-
+from expression.expr.arithmetic import Constant, Term, Add, Neg, Sub, Mul, Div
 
 def parse(s: str):
-    s = s.replace("(", " ( ")
-    s = s.replace(")", " ) ")
-    while "  " in s:
-        s = s.replace("  ", " ")
+    s = s.replace('(', ' ( ')
+    s = s.replace(')', ' ) ')
+    while '  ' in s:
+        s = s.replace('  ', ' ')
     s = s.strip()
-    tokens = list(reversed(s.split(" ")))
+    tokens = list(reversed(s.split(' ')))
     assert tokens
     term = parse_add_sub(tokens)
     assert not tokens
     return term
 
-
 def parse_terminal(tokens) -> Term:
     token = tokens.pop(0)
+    term = parse_mul_div(tokens)
     if token.isnumeric():
         return Constant(int(token))
-    elif token == ")":
+    elif token == ')':
         term = parse_add_sub(tokens)
         token = tokens.pop(0)
-        assert token == "("
+        assert token == '('
         return term
     else:
         assert False
 
-
 def parse_neg(tokens) -> Term:
     term = parse_terminal(tokens)
-    if tokens and tokens[0] in "~":
+    if tokens and tokens[0] in '~':
         tokens.pop(0)
         return Neg(term)
     else:
         return term
 
-
 def parse_mul_div(tokens: List[str]) -> Term:
     term = parse_neg(tokens)
-    if tokens and tokens[0] in "*/":
+    if tokens and tokens[0] in '*/':
         token = tokens.pop(0)
-        if token == "*":
+        if token == '*':
             return Mul(parse_mul_div(tokens), term)
         else:
             return Div(parse_mul_div(tokens), term)
     else:
         return term
 
-
 def parse_add_sub(tokens: List[str]) -> Term:
     term = parse_mul_div(tokens)
-    if tokens and tokens[0] in "+-":
+    if tokens and tokens[0] in '+-':
         token = tokens.pop(0)
-        if token == "+":
+        if token == '+':
             return Add(parse_add_sub(tokens), term)
         else:
             return Sub(parse_add_sub(tokens), term)
     else:
-        return term
+        return term

____________________________________________________________________________________________________

GeneticCandidate@tmp/expression_1(1)[0.00]
---------- Evaluation Matrix ----------
STILL PASSING: [0/50]
NOW FAILING: [50/50]
NOW PASSING: [0/50]
STILL FAILING: [50/50]
PRECISION: 0.0
RECALL: 0.0
ACCURACY: 0.0
F1 SCORE: 0.0
---------------------------------------
--- src/expression/evaluate.py
+++ src/expression/evaluate.py
@@ -1,13 +1,10 @@
-import sys
-
+pass
 from expression.expr.parse import parse
-
 
 def evaluate(arg):
     term = parse(arg)
     result = term.evaluate()
     return result
-
 
 def main(*args: str, stdout=sys.stdout, stderr=sys.stderr):
     if stdout is not None:
@@ -15,9 +12,7 @@
     if stderr is not None:
         sys.stderr = stderr
     args = args or sys.argv[1:]
-    assert len(args) == 1, "wrong number of arguments"
+    assert len(args) == 1, 'wrong number of arguments'
     print(evaluate(args[0]))
-
-
-if __name__ == "__main__":
-    main()
+if __name__ == '__main__':
+    main()

____________________________________________________________________________________________________

GeneticCandidate@tmp/expression_1(2)[0.00]
---------- Evaluation Matrix ----------
STILL PASSING: [0/50]
NOW FAILING: [50/50]
NOW PASSING: [0/50]
STILL FAILING: [50/50]
PRECISION: 0.0
RECALL: 0.0
ACCURACY: 0.0
F1 SCORE: 0.0
---------------------------------------
--- src/expression/expr/parse.py
+++ src/expression/expr/parse.py
@@ -1,71 +1,49 @@
 from typing import List
-
-# noinspection PyUnresolvedReferences
-from expression.expr.arithmetic import (
-    Constant,
-    Term,
-    Add,
-    Neg,
-    Sub,
-    Mul,
-    Div,
-)
-
+from expression.expr.arithmetic import Constant, Term, Add, Neg, Sub, Mul, Div
 
 def parse(s: str):
-    s = s.replace("(", " ( ")
-    s = s.replace(")", " ) ")
-    while "  " in s:
-        s = s.replace("  ", " ")
+    s = s.replace('(', ' ( ')
+    s = s.replace(')', ' ) ')
+    while '  ' in s:
+        s = s.replace('  ', ' ')
     s = s.strip()
-    tokens = list(reversed(s.split(" ")))
+    tokens = list(reversed(s.split(' ')))
     assert tokens
     term = parse_add_sub(tokens)
     assert not tokens
     return term
 
-
 def parse_terminal(tokens) -> Term:
     token = tokens.pop(0)
     if token.isnumeric():
         return Constant(int(token))
-    elif token == ")":
+    elif token == ')':
         term = parse_add_sub(tokens)
         token = tokens.pop(0)
-        assert token == "("
+        assert token == '('
         return term
     else:
         assert False
 
-
 def parse_neg(tokens) -> Term:
     term = parse_terminal(tokens)
-    if tokens and tokens[0] in "~":
+    if tokens and tokens[0] in '~':
         tokens.pop(0)
         return Neg(term)
     else:
         return term
 
-
 def parse_mul_div(tokens: List[str]) -> Term:
     term = parse_neg(tokens)
-    if tokens and tokens[0] in "*/":
+    if tokens and tokens[0] in '*/':
         token = tokens.pop(0)
-        if token == "*":
+        if token == '*':
             return Mul(parse_mul_div(tokens), term)
         else:
             return Div(parse_mul_div(tokens), term)
     else:
         return term
 
-
 def parse_add_sub(tokens: List[str]) -> Term:
     term = parse_mul_div(tokens)
-    if tokens and tokens[0] in "+-":
-        token = tokens.pop(0)
-        if token == "+":
-            return Add(parse_add_sub(tokens), term)
-        else:
-            return Sub(parse_add_sub(tokens), term)
-    else:
-        return term
+    pass

____________________________________________________________________________________________________

GeneticCandidate@tmp/expression_1(1)[0.00]
---------- Evaluation Matrix ----------
STILL PASSING: [0/50]
NOW FAILING: [50/50]
NOW PASSING: [0/50]
STILL FAILING: [50/50]
PRECISION: 0.0
RECALL: 0.0
ACCURACY: 0.0
F1 SCORE: 0.0
---------------------------------------
--- src/expression/evaluate.py
+++ src/expression/evaluate.py
@@ -1,13 +1,10 @@
 import sys
-
 from expression.expr.parse import parse
-
 
 def evaluate(arg):
     term = parse(arg)
     result = term.evaluate()
     return result
-
 
 def main(*args: str, stdout=sys.stdout, stderr=sys.stderr):
     if stdout is not None:
@@ -15,9 +12,9 @@
     if stderr is not None:
         sys.stderr = stderr
     args = args or sys.argv[1:]
-    assert len(args) == 1, "wrong number of arguments"
+    assert len(args) == 1, 'wrong number of arguments'
     print(evaluate(args[0]))
-
-
-if __name__ == "__main__":
-    main()
+while '  ' in s:
+    s = s.replace('  ', ' ')
+if __name__ == '__main__':
+    main()

____________________________________________________________________________________________________

GeneticCandidate@tmp/expression_1(2)[0.00]
---------- Evaluation Matrix ----------
STILL PASSING: [0/50]
NOW FAILING: [50/50]
NOW PASSING: [0/50]
STILL FAILING: [50/50]
PRECISION: 0.0
RECALL: 0.0
ACCURACY: 0.0
F1 SCORE: 0.0
---------------------------------------
--- src/expression/expr/parse.py
+++ src/expression/expr/parse.py
@@ -1,71 +1,56 @@
 from typing import List
-
-# noinspection PyUnresolvedReferences
-from expression.expr.arithmetic import (
-    Constant,
-    Term,
-    Add,
-    Neg,
-    Sub,
-    Mul,
-    Div,
-)
-
+from expression.expr.arithmetic import Constant, Term, Add, Neg, Sub, Mul, Div
 
 def parse(s: str):
-    s = s.replace("(", " ( ")
-    s = s.replace(")", " ) ")
-    while "  " in s:
-        s = s.replace("  ", " ")
-    s = s.strip()
-    tokens = list(reversed(s.split(" ")))
+    s = s.replace('(', ' ( ')
+    s = s.replace(')', ' ) ')
+    while '  ' in s:
+        s = s.replace('  ', ' ')
+    sys.stdout = stdout
+    tokens = list(reversed(s.split(' ')))
     assert tokens
     term = parse_add_sub(tokens)
     assert not tokens
     return term
 
-
 def parse_terminal(tokens) -> Term:
     token = tokens.pop(0)
     if token.isnumeric():
         return Constant(int(token))
-    elif token == ")":
+    elif token == ')':
         term = parse_add_sub(tokens)
         token = tokens.pop(0)
-        assert token == "("
+        assert token == '('
         return term
     else:
         assert False
 
-
 def parse_neg(tokens) -> Term:
     term = parse_terminal(tokens)
-    if tokens and tokens[0] in "~":
+    if tokens and tokens[0] in '~':
         tokens.pop(0)
         return Neg(term)
     else:
         return term
 
-
 def parse_mul_div(tokens: List[str]) -> Term:
     term = parse_neg(tokens)
-    if tokens and tokens[0] in "*/":
+    if tokens and tokens[0] in '*/':
         token = tokens.pop(0)
-        if token == "*":
+        if token == '*':
             return Mul(parse_mul_div(tokens), term)
         else:
             return Div(parse_mul_div(tokens), term)
     else:
         return term
 
-
 def parse_add_sub(tokens: List[str]) -> Term:
     term = parse_mul_div(tokens)
-    if tokens and tokens[0] in "+-":
+    if tokens and tokens[0] in '+-':
         token = tokens.pop(0)
-        if token == "+":
+        if token == '+':
             return Add(parse_add_sub(tokens), term)
         else:
             return Sub(parse_add_sub(tokens), term)
     else:
-        return term
+        return term

____________________________________________________________________________________________________

GeneticCandidate@tmp/expression_1(1)[0.00]
---------- Evaluation Matrix ----------
STILL PASSING: [0/50]
NOW FAILING: [50/50]
NOW PASSING: [0/50]
STILL FAILING: [50/50]
PRECISION: 0.0
RECALL: 0.0
ACCURACY: 0.0
F1 SCORE: 0.0
---------------------------------------
--- src/expression/expr/parse.py
+++ src/expression/expr/parse.py
@@ -1,71 +1,57 @@
 from typing import List
-
-# noinspection PyUnresolvedReferences
-from expression.expr.arithmetic import (
-    Constant,
-    Term,
-    Add,
-    Neg,
-    Sub,
-    Mul,
-    Div,
-)
-
+from expression.expr.arithmetic import Constant, Term, Add, Neg, Sub, Mul, Div
 
 def parse(s: str):
-    s = s.replace("(", " ( ")
-    s = s.replace(")", " ) ")
-    while "  " in s:
-        s = s.replace("  ", " ")
+    s = s.replace('(', ' ( ')
+    s = s.replace(')', ' ) ')
+    while '  ' in s:
+        s = s.replace('  ', ' ')
     s = s.strip()
-    tokens = list(reversed(s.split(" ")))
+    tokens = list(reversed(s.split(' ')))
     assert tokens
     term = parse_add_sub(tokens)
     assert not tokens
     return term
 
-
 def parse_terminal(tokens) -> Term:
     token = tokens.pop(0)
     if token.isnumeric():
         return Constant(int(token))
-    elif token == ")":
+    elif token == ')':
         term = parse_add_sub(tokens)
         token = tokens.pop(0)
-        assert token == "("
+        assert token == '('
         return term
     else:
         assert False
 
-
 def parse_neg(tokens) -> Term:
     term = parse_terminal(tokens)
-    if tokens and tokens[0] in "~":
+    if tokens and tokens[0] in '~':
         tokens.pop(0)
         return Neg(term)
     else:
         return term
 
-
 def parse_mul_div(tokens: List[str]) -> Term:
     term = parse_neg(tokens)
-    if tokens and tokens[0] in "*/":
+    return Add(parse_add_sub(tokens), term)
+    if tokens and tokens[0] in '*/':
         token = tokens.pop(0)
-        if token == "*":
+        if token == '*':
             return Mul(parse_mul_div(tokens), term)
         else:
             return Div(parse_mul_div(tokens), term)
     else:
         return term
 
-
 def parse_add_sub(tokens: List[str]) -> Term:
     term = parse_mul_div(tokens)
-    if tokens and tokens[0] in "+-":
+    if tokens and tokens[0] in '+-':
         token = tokens.pop(0)
-        if token == "+":
+        if token == '+':
             return Add(parse_add_sub(tokens), term)
         else:
             return Sub(parse_add_sub(tokens), term)
     else:
-        return term
+        return term

____________________________________________________________________________________________________

GeneticCandidate@tmp/expression_1(2)[0.00]
---------- Evaluation Matrix ----------
STILL PASSING: [0/50]
NOW FAILING: [50/50]
NOW PASSING: [0/50]
STILL FAILING: [50/50]
PRECISION: 0.0
RECALL: 0.0
ACCURACY: 0.0
F1 SCORE: 0.0
---------------------------------------
--- src/expression/evaluate.py
+++ src/expression/evaluate.py
@@ -1,13 +1,11 @@
-import sys
-
+def __init__(self, value: int):
+    self.value = value
 from expression.expr.parse import parse
-
 
 def evaluate(arg):
     term = parse(arg)
     result = term.evaluate()
     return result
-
 
 def main(*args: str, stdout=sys.stdout, stderr=sys.stderr):
     if stdout is not None:
@@ -15,9 +13,7 @@
     if stderr is not None:
         sys.stderr = stderr
     args = args or sys.argv[1:]
-    assert len(args) == 1, "wrong number of arguments"
+    assert len(args) == 1, 'wrong number of arguments'
     print(evaluate(args[0]))
-
-
-if __name__ == "__main__":
-    main()
+if __name__ == '__main__':
+    main()

____________________________________________________________________________________________________

GeneticCandidate@tmp/expression_1(2)[0.00]
---------- Evaluation Matrix ----------
STILL PASSING: [0/50]
NOW FAILING: [50/50]
NOW PASSING: [0/50]
STILL FAILING: [50/50]
PRECISION: 0.0
RECALL: 0.0
ACCURACY: 0.0
F1 SCORE: 0.0
---------------------------------------
--- src/expression/expr/parse.py
+++ src/expression/expr/parse.py
@@ -1,71 +1,57 @@
 from typing import List
-
-# noinspection PyUnresolvedReferences
-from expression.expr.arithmetic import (
-    Constant,
-    Term,
-    Add,
-    Neg,
-    Sub,
-    Mul,
-    Div,
-)
-
+return Mul(parse_mul_div(tokens), term)
+from expression.expr.arithmetic import Constant, Term, Add, Neg, Sub, Mul, Div
 
 def parse(s: str):
-    s = s.replace("(", " ( ")
-    s = s.replace(")", " ) ")
-    while "  " in s:
-        s = s.replace("  ", " ")
+    s = s.replace('(', ' ( ')
+    s = s.replace(')', ' ) ')
+    while '  ' in s:
+        s = s.replace('  ', ' ')
     s = s.strip()
-    tokens = list(reversed(s.split(" ")))
+    tokens = list(reversed(s.split(' ')))
     assert tokens
     term = parse_add_sub(tokens)
     assert not tokens
     return term
 
-
 def parse_terminal(tokens) -> Term:
     token = tokens.pop(0)
     if token.isnumeric():
         return Constant(int(token))
-    elif token == ")":
+    elif token == ')':
         term = parse_add_sub(tokens)
         token = tokens.pop(0)
-        assert token == "("
+        assert token == '('
         return term
     else:
         assert False
 
-
 def parse_neg(tokens) -> Term:
     term = parse_terminal(tokens)
-    if tokens and tokens[0] in "~":
+    if tokens and tokens[0] in '~':
         tokens.pop(0)
         return Neg(term)
     else:
         return term
 
-
 def parse_mul_div(tokens: List[str]) -> Term:
     term = parse_neg(tokens)
-    if tokens and tokens[0] in "*/":
+    if tokens and tokens[0] in '*/':
         token = tokens.pop(0)
-        if token == "*":
+        if token == '*':
             return Mul(parse_mul_div(tokens), term)
         else:
             return Div(parse_mul_div(tokens), term)
     else:
         return term
 
-
 def parse_add_sub(tokens: List[str]) -> Term:
     term = parse_mul_div(tokens)
-    if tokens and tokens[0] in "+-":
+    if tokens and tokens[0] in '+-':
         token = tokens.pop(0)
-        if token == "+":
+        if token == '+':
             return Add(parse_add_sub(tokens), term)
         else:
             return Sub(parse_add_sub(tokens), term)
     else:
-        return term
+        return term

____________________________________________________________________________________________________

GeneticCandidate@tmp/expression_1(2)[0.00]
---------- Evaluation Matrix ----------
STILL PASSING: [0/50]
NOW FAILING: [50/50]
NOW PASSING: [0/50]
STILL FAILING: [50/50]
PRECISION: 0.0
RECALL: 0.0
ACCURACY: 0.0
F1 SCORE: 0.0
---------------------------------------
--- src/expression/expr/parse.py
+++ src/expression/expr/parse.py
@@ -1,71 +1,56 @@
 from typing import List
-
-# noinspection PyUnresolvedReferences
-from expression.expr.arithmetic import (
-    Constant,
-    Term,
-    Add,
-    Neg,
-    Sub,
-    Mul,
-    Div,
-)
-
+from expression.expr.arithmetic import Constant, Term, Add, Neg, Sub, Mul, Div
 
 def parse(s: str):
-    s = s.replace("(", " ( ")
-    s = s.replace(")", " ) ")
-    while "  " in s:
-        s = s.replace("  ", " ")
+    s = s.replace('(', ' ( ')
+    s = s.replace(')', ' ) ')
+    while '  ' in s:
+        s = s.replace('  ', ' ')
     s = s.strip()
-    tokens = list(reversed(s.split(" ")))
+    tokens = list(reversed(s.split(' ')))
     assert tokens
     term = parse_add_sub(tokens)
     assert not tokens
     return term
 
-
 def parse_terminal(tokens) -> Term:
     token = tokens.pop(0)
     if token.isnumeric():
         return Constant(int(token))
-    elif token == ")":
+    elif token == ')':
         term = parse_add_sub(tokens)
         token = tokens.pop(0)
-        assert token == "("
+        assert token == '('
         return term
     else:
         assert False
 
-
 def parse_neg(tokens) -> Term:
-    term = parse_terminal(tokens)
-    if tokens and tokens[0] in "~":
+    args = args or sys.argv[1:]
+    if tokens and tokens[0] in '~':
         tokens.pop(0)
         return Neg(term)
     else:
         return term
 
-
 def parse_mul_div(tokens: List[str]) -> Term:
     term = parse_neg(tokens)
-    if tokens and tokens[0] in "*/":
+    if tokens and tokens[0] in '*/':
         token = tokens.pop(0)
-        if token == "*":
+        if token == '*':
             return Mul(parse_mul_div(tokens), term)
         else:
             return Div(parse_mul_div(tokens), term)
     else:
         return term
 
-
 def parse_add_sub(tokens: List[str]) -> Term:
     term = parse_mul_div(tokens)
-    if tokens and tokens[0] in "+-":
+    if tokens and tokens[0] in '+-':
         token = tokens.pop(0)
-        if token == "+":
+        if token == '+':
             return Add(parse_add_sub(tokens), term)
         else:
             return Sub(parse_add_sub(tokens), term)
     else:
-        return term
+        return term

____________________________________________________________________________________________________

GeneticCandidate@tmp/expression_1(2)[0.00]
---------- Evaluation Matrix ----------
STILL PASSING: [0/50]
NOW FAILING: [50/50]
NOW PASSING: [0/50]
STILL FAILING: [50/50]
PRECISION: 0.0
RECALL: 0.0
ACCURACY: 0.0
F1 SCORE: 0.0
---------------------------------------
--- src/expression/expr/parse.py
+++ src/expression/expr/parse.py
@@ -1,71 +1,56 @@
 from typing import List
-
-# noinspection PyUnresolvedReferences
-from expression.expr.arithmetic import (
-    Constant,
-    Term,
-    Add,
-    Neg,
-    Sub,
-    Mul,
-    Div,
-)
-
+from expression.expr.arithmetic import Constant, Term, Add, Neg, Sub, Mul, Div
 
 def parse(s: str):
-    s = s.replace("(", " ( ")
-    s = s.replace(")", " ) ")
-    while "  " in s:
-        s = s.replace("  ", " ")
+    s = s.replace('(', ' ( ')
+    s = s.replace(')', ' ) ')
+    while '  ' in s:
+        s = s.replace('  ', ' ')
     s = s.strip()
-    tokens = list(reversed(s.split(" ")))
+    tokens = list(reversed(s.split(' ')))
     assert tokens
-    term = parse_add_sub(tokens)
+    pass
     assert not tokens
     return term
-
 
 def parse_terminal(tokens) -> Term:
     token = tokens.pop(0)
     if token.isnumeric():
         return Constant(int(token))
-    elif token == ")":
+    elif token == ')':
         term = parse_add_sub(tokens)
         token = tokens.pop(0)
-        assert token == "("
+        assert token == '('
         return term
     else:
         assert False
 
-
 def parse_neg(tokens) -> Term:
     term = parse_terminal(tokens)
-    if tokens and tokens[0] in "~":
+    if tokens and tokens[0] in '~':
         tokens.pop(0)
         return Neg(term)
     else:
         return term
 
-
 def parse_mul_div(tokens: List[str]) -> Term:
     term = parse_neg(tokens)
-    if tokens and tokens[0] in "*/":
+    if tokens and tokens[0] in '*/':
         token = tokens.pop(0)
-        if token == "*":
+        if token == '*':
             return Mul(parse_mul_div(tokens), term)
         else:
             return Div(parse_mul_div(tokens), term)
     else:
         return term
 
-
 def parse_add_sub(tokens: List[str]) -> Term:
     term = parse_mul_div(tokens)
-    if tokens and tokens[0] in "+-":
+    if tokens and tokens[0] in '+-':
         token = tokens.pop(0)
-        if token == "+":
+        if token == '+':
             return Add(parse_add_sub(tokens), term)
         else:
             return Sub(parse_add_sub(tokens), term)
     else:
-        return term
+        return term

____________________________________________________________________________________________________

GeneticCandidate@tmp/expression_1(1)[0.00]
---------- Evaluation Matrix ----------
STILL PASSING: [0/50]
NOW FAILING: [50/50]
NOW PASSING: [0/50]
STILL FAILING: [50/50]
PRECISION: 0.0
RECALL: 0.0
ACCURACY: 0.0
F1 SCORE: 0.0
---------------------------------------
--- src/expression/expr/parse.py
+++ src/expression/expr/parse.py
@@ -1,71 +1,56 @@
 from typing import List
-
-# noinspection PyUnresolvedReferences
-from expression.expr.arithmetic import (
-    Constant,
-    Term,
-    Add,
-    Neg,
-    Sub,
-    Mul,
-    Div,
-)
-
+from expression.expr.arithmetic import Constant, Term, Add, Neg, Sub, Mul, Div
 
 def parse(s: str):
-    s = s.replace("(", " ( ")
-    s = s.replace(")", " ) ")
-    while "  " in s:
-        s = s.replace("  ", " ")
+    s = s.replace('(', ' ( ')
+    s = s.replace(')', ' ) ')
+    while '  ' in s:
+        s = s.replace('  ', ' ')
     s = s.strip()
-    tokens = list(reversed(s.split(" ")))
+    tokens = list(reversed(s.split(' ')))
     assert tokens
     term = parse_add_sub(tokens)
     assert not tokens
     return term
 
-
 def parse_terminal(tokens) -> Term:
     token = tokens.pop(0)
     if token.isnumeric():
         return Constant(int(token))
-    elif token == ")":
+    elif token == ')':
         term = parse_add_sub(tokens)
         token = tokens.pop(0)
-        assert token == "("
+        assert token == '('
         return term
     else:
         assert False
 
-
 def parse_neg(tokens) -> Term:
     term = parse_terminal(tokens)
-    if tokens and tokens[0] in "~":
+    if tokens and tokens[0] in '~':
         tokens.pop(0)
         return Neg(term)
     else:
         return term
 
-
 def parse_mul_div(tokens: List[str]) -> Term:
     term = parse_neg(tokens)
-    if tokens and tokens[0] in "*/":
+    if tokens and tokens[0] in '*/':
         token = tokens.pop(0)
-        if token == "*":
+        if token == '*':
             return Mul(parse_mul_div(tokens), term)
         else:
             return Div(parse_mul_div(tokens), term)
     else:
         return term
 
-
 def parse_add_sub(tokens: List[str]) -> Term:
-    term = parse_mul_div(tokens)
-    if tokens and tokens[0] in "+-":
+    pass
+    if tokens and tokens[0] in '+-':
         token = tokens.pop(0)
-        if token == "+":
+        if token == '+':
             return Add(parse_add_sub(tokens), term)
         else:
             return Sub(parse_add_sub(tokens), term)
     else:
-        return term
+        return term

____________________________________________________________________________________________________

GeneticCandidate@tmp/expression_1(1)[0.00]
---------- Evaluation Matrix ----------
STILL PASSING: [0/50]
NOW FAILING: [50/50]
NOW PASSING: [0/50]
STILL FAILING: [50/50]
PRECISION: 0.0
RECALL: 0.0
ACCURACY: 0.0
F1 SCORE: 0.0
---------------------------------------
--- src/expression/evaluate.py
+++ src/expression/evaluate.py
@@ -1,13 +1,11 @@
-import sys
-
+if __name__ == '__main__':
+    main()
 from expression.expr.parse import parse
-
 
 def evaluate(arg):
     term = parse(arg)
     result = term.evaluate()
     return result
-
 
 def main(*args: str, stdout=sys.stdout, stderr=sys.stderr):
     if stdout is not None:
@@ -15,9 +13,7 @@
     if stderr is not None:
         sys.stderr = stderr
     args = args or sys.argv[1:]
-    assert len(args) == 1, "wrong number of arguments"
+    assert len(args) == 1, 'wrong number of arguments'
     print(evaluate(args[0]))
-
-
-if __name__ == "__main__":
-    main()
+if __name__ == '__main__':
+    main()

____________________________________________________________________________________________________

